<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黄圣杰</title>
  
  <subtitle>bjfuhsj.top</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2024-09-21T15:10:19.749Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>黄圣杰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《240921-硕士论文致谢补档》</title>
    <link href="http://yoursite.com/2024/09/21/240921-%E8%87%B4%E8%B0%A2%E8%A1%A5%E6%A1%A3/"/>
    <id>http://yoursite.com/2024/09/21/240921-%E8%87%B4%E8%B0%A2%E8%A1%A5%E6%A1%A3/</id>
    <published>2024-09-21T14:16:54.000Z</published>
    <updated>2024-09-21T15:10:19.749Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《爱与痛的边缘》—王菲</p><p><audio src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/2024/%E9%9F%B3%E4%B9%90/%E7%8E%8B%E8%8F%B2%20-%20%E7%88%B1%E4%B8%8E%E7%97%9B%E7%9A%84%E8%BE%B9%E7%BC%98.mp3"></audio></p><p>2024.09.21</p><ul><li>度过了一个阶段性的锻炼，难得有时间停下脚步，收拾收拾心情，好再出发。</li><li>考古自己过往的成果文件，发现之前在知网选择了隐藏致谢。便站定，再次翻看起了自己曾经真情流露的文字。再次阅读，还是能让我感到欣慰，并感慨万千。虽然三年的硕士生涯，在前两年把我折磨得天昏地暗，但依然很感谢那段日子里，努力向上攀爬的自己。这不像是军训后普遍存在的那种“斯德哥尔摩综合征”式的回味，而是对命运就此被改变的那种“事后烟”的舒畅，开心、疲惫、后怕、敬畏多种情愫交织杂糅在一起，构成了那段时间的高度美好概括。</li></ul><a id="more"></a><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/image/%E7%A1%95%E5%A3%AB%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E8%87%B4%E8%B0%A2_%E9%A1%B5%E9%9D%A2_1.png" alt="硕士毕业论文致谢_页面_1"></p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/image/a9de23c6f44da0d883122e491a7e93a.png" alt="1"></p><ul><li>致谢里没写的，还有在研一时，枕头旁掉落的一堆头发、在长期熬夜久坐后的腰肌劳损，在研二时克服疫情天天外出实习的波折困难。</li></ul><p>算了，还有好多可以唠嗑的，今天很晚了，要睡了，早睡真好~</p><p>祝福明天的自己更美好、更优秀、更幸运。也希望能遇到双向奔赴的爱情。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《爱与痛的边缘》—王菲&lt;/p&gt;
&lt;p&gt;&lt;audio src=&quot;https://blog-1301959139.cos.ap-beijing.myqcloud.com/2024/%E9%9F%B3%E4%B9%90/%E7%8E%8B%E8%8F%B2%20-%20%E7%88%B1%E4%B8%8E%E7%97%9B%E7%9A%84%E8%BE%B9%E7%BC%98.mp3&quot;&gt;&lt;/audio&gt;&lt;/p&gt;
&lt;p&gt;2024.09.21&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;度过了一个阶段性的锻炼，难得有时间停下脚步，收拾收拾心情，好再出发。&lt;/li&gt;
&lt;li&gt;考古自己过往的成果文件，发现之前在知网选择了隐藏致谢。便站定，再次翻看起了自己曾经真情流露的文字。再次阅读，还是能让我感到欣慰，并感慨万千。虽然三年的硕士生涯，在前两年把我折磨得天昏地暗，但依然很感谢那段日子里，努力向上攀爬的自己。这不像是军训后普遍存在的那种“斯德哥尔摩综合征”式的回味，而是对命运就此被改变的那种“事后烟”的舒畅，开心、疲惫、后怕、敬畏多种情愫交织杂糅在一起，构成了那段时间的高度美好概括。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="作家计划" scheme="http://yoursite.com/categories/%E4%BD%9C%E5%AE%B6%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>python 切片的一些混淆点（备忘）</title>
    <link href="http://yoursite.com/2023/07/08/%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2023/07/08/%E7%AC%94%E8%AE%B0/</id>
    <published>2023-07-08T08:38:20.866Z</published>
    <updated>2020-08-17T11:50:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-经常混淆的py切片细节"><a href="#1-经常混淆的py切片细节" class="headerlink" title="1.经常混淆的py切片细节"></a>1.经常混淆的py切片细节</h2><a id="more"></a><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200716200314.png" alt="image-20200716200313100"></p><h1 id="python-中的-1-和-1"><a href="#python-中的-1-和-1" class="headerlink" title="python 中的 [:-1] 和 [::-1]"></a>python 中的 [:-1] 和 [::-1]</h1><ul><li><p><a href="https://www.runoob.com/note/51257" target="_blank" rel="noopener">https://www.runoob.com/note/51257</a></p></li><li><pre><code class="python">a=<span class="string">'python'</span>b=a[::<span class="number">-1</span>]print(b) <span class="comment">#nohtyp</span>c=a[::<span class="number">-2</span>]print(c) <span class="comment">#nhy</span><span class="comment">#从后往前数的话，最后一个位置为-1</span>d=a[:<span class="number">-1</span>]  <span class="comment">#从位置0到位置-1之前的数</span>print(d)  <span class="comment">#pytho</span>e=a[:<span class="number">-2</span>]  <span class="comment">#从位置0到位置-2之前的数</span>print(e)  <span class="comment">#pyth</span><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* &#96;&#96;&#96;python</span><br><span class="line">  b &#x3D; a[i:j]   # 表示复制a[i]到a[j-1]，以生成新的list对象</span><br><span class="line">  </span><br><span class="line">  a &#x3D; [0,1,2,3,4,5,6,7,8,9]</span><br><span class="line">  b &#x3D; a[1:3]   # [1,2]</span><br><span class="line">  </span><br><span class="line">  # 当i缺省时，默认为0，即 a[:3]相当于 a[0:3]</span><br><span class="line">  # 当j缺省时，默认为len(alist), 即a[1:]相当于a[1:10]</span><br><span class="line">  # 当i,j都缺省时，a[:]就相当于完整复制一份a</span><br><span class="line">  </span><br><span class="line">  b &#x3D; a[i:j:s]    # 表示：i,j与上面的一样，但s表示步进，缺省为1.</span><br><span class="line">  # 所以a[i:j:1]相当于a[i:j]</span><br><span class="line">  </span><br><span class="line">  # 当s&lt;0时，i缺省时，默认为-1. j缺省时，默认为-len(a)-1</span><br><span class="line">  # 所以a[::-1]相当于 a[-1:-len(a)-1:-1]，也就是从最后一个元素到第一个元素复制一遍，即倒序。</span><br></pre></td></tr></table></figure></code></pre></li></ul><hr><h2 id="2-关于-torch-的pad：full模式（相对于tf中的same模式）"><a href="#2-关于-torch-的pad：full模式（相对于tf中的same模式）" class="headerlink" title="2.关于 torch 的pad：full模式（相对于tf中的same模式）"></a>2.关于 torch 的pad：full模式（相对于tf中的same模式）</h2><p>$$<br>              H_{out} = \left\lfloor\frac{H_{in}  + 2 \times \text{padding}[0] - \text{dilation}[0]<br>                        \times (\text{kernel_size}[0] - 1) - 1}{\text{stride}[0]} + 1\right\rfloor</p><pre><code>W_{out} = \left\lfloor\frac{W_{in}  + 2 \times \text{padding}[1] - \text{dilation}[1]          \times (\text{kernel_size}[1] - 1) - 1}{\text{stride}[1]} + 1\right\rfloor</code></pre><p>$$</p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200801174740.png" alt="image-20200801174738560"></p><h2 id="相比tensorflow，PyTorch需要用户清楚的知道的自己的卷积核选取对结果的影响。"><a href="#相比tensorflow，PyTorch需要用户清楚的知道的自己的卷积核选取对结果的影响。" class="headerlink" title="相比tensorflow，PyTorch需要用户清楚的知道的自己的卷积核选取对结果的影响。"></a>相比tensorflow，PyTorch需要用户清楚的知道的自己的卷积核选取对结果的影响。</h2><ul><li><strong>简单一点</strong>：先只看 t = kernel【0】// 2；</li><li>Kernel【0】为奇数，那么padding就等于 t;</li><li>否则，kernel【0】为偶数，那么padding就等于 【t - 1】</li></ul><hr><h2 id="3-反卷积"><a href="#3-反卷积" class="headerlink" title="3.反卷积"></a>3.反卷积</h2><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200801184750.png" alt="image-20200801184748828"></p><p><a href="https://blog.csdn.net/g11d111/article/details/82665265" target="_blank" rel="noopener">https://blog.csdn.net/g11d111/article/details/82665265</a></p><ul><li>反卷积这部分用的少，公式其实就是正卷积中，in 和 out 对调；</li><li>只不过 反卷积没有了 正卷积 中 的 <strong>向下取整</strong> 的操作</li><li>所以在反卷积中， 需要按规矩公式，简单计算一下padding 尺寸参数；</li><li>最简单就是用局部代码输出看一下结果，看是否符合输入输出尺寸要求</li></ul><hr><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200801193707.png" alt="image-20200801193706275"></p><p><a href="https://blog.csdn.net/m0_37586991/article/details/87855342" target="_blank" rel="noopener">https://blog.csdn.net/m0_37586991/article/details/87855342</a></p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200801194743.png" alt="image-20200801194739307"></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-经常混淆的py切片细节&quot;&gt;&lt;a href=&quot;#1-经常混淆的py切片细节&quot; class=&quot;headerlink&quot; title=&quot;1.经常混淆的py切片细节&quot;&gt;&lt;/a&gt;1.经常混淆的py切片细节&lt;/h2&gt;
    
    </summary>
    
    
      <category term="-[python]" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="-[python] -[编程]" scheme="http://yoursite.com/tags/python-%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>关于pyworld.load 读取音频和soundfile.read 差别</title>
    <link href="http://yoursite.com/2023/07/08/%E5%85%B3%E4%BA%8Epyworld.load%20%E8%AF%BB%E5%8F%96%E9%9F%B3%E9%A2%91%E5%92%8Csoundfile.read%20%E5%B7%AE%E5%88%AB/"/>
    <id>http://yoursite.com/2023/07/08/%E5%85%B3%E4%BA%8Epyworld.load%20%E8%AF%BB%E5%8F%96%E9%9F%B3%E9%A2%91%E5%92%8Csoundfile.read%20%E5%B7%AE%E5%88%AB/</id>
    <published>2023-07-08T08:38:20.861Z</published>
    <updated>2024-09-21T15:11:15.304Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><a id="more"></a><h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>在pyworld使用前，一般需要读取音频文件：</p><ul><li><p>librosa.load() 默认得到的是float32类型的数据，所以一般会再跟上 x.astype(np.float64)</p><ul><li>而恰恰是这么一个Numpy类型转换，会导致得到的 ap 特征中会含有 Nan 数据，这会导致最终的计算出现不必要的偏差；</li></ul></li></ul><!--more--><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">f"ap <span class="subst">&#123;np.isnan(ap).any()&#125;</span>"</span>)  <span class="comment"># 返回True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#统计nan个数</span></span><br><span class="line">t = ap</span><br><span class="line">t = t[np.isnan(t)]  <span class="comment"># 用切片法 + 条件限制，来得到 nan 值的切片</span></span><br><span class="line"><span class="comment"># t = t[np.where(np.isnan(t))]</span></span><br><span class="line">print(t.shape)  <span class="comment"># （4k+, ）</span></span><br></pre></td></tr></table></figure><ul><li><p>（这个问题和怎么计算得到ap无关：尝试了 world.wav2worl（）和 pyworld.harvest + cheaptrick + d4c路径，结果都一样）</p></li><li><p>Soundfile.read()  # 默认的数据返回值是 float64，所以可以直接得到所要求的数据格式</p></li><li><p>其中，对应的函数参数调整：sr 变为 samplerate ， mono 的单通道 改用 channels=1</p></li></ul><h2 id="Ps-附上代码和-issue网址"><a href="#Ps-附上代码和-issue网址" class="headerlink" title="Ps.附上代码和 issue网址"></a>Ps.附上代码和 issue网址</h2><p>[issue][<a href="https://github.com/JeremyCCHsu/Python-Wrapper-for-World-Vocoder/issues/50]" target="_blank" rel="noopener">https://github.com/JeremyCCHsu/Python-Wrapper-for-World-Vocoder/issues/50]</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pyworld <span class="keyword">as</span> world</span><br><span class="line"><span class="keyword">import</span> pyworld</span><br><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"><span class="keyword">import</span> librosa.display</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> soundfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># wav,fs = librosa.load(os.getcwd()+"/bed (537).wav")</span></span><br><span class="line">wav, fs = soundfile.read(os.getcwd()+<span class="string">"/bed (537).wav"</span>)</span><br><span class="line"><span class="comment"># wav = wav.astype(np.float64)</span></span><br><span class="line"><span class="comment"># print(wav[0].type)  # 'numpy.float64' object has no attribute 'type'</span></span><br><span class="line">frame_period = <span class="number">5.0</span></span><br><span class="line">hop_length = int(fs * frame_period * <span class="number">0.001</span>)</span><br><span class="line">fftlen = world.get_cheaptrick_fft_size(fs)</span><br><span class="line"></span><br><span class="line">f0, timeaxis = pyworld.harvest(wav, fs, frame_period=frame_period, f0_floor=<span class="number">71.0</span>, f0_ceil=<span class="number">800.0</span>)</span><br><span class="line">sp = pyworld.cheaptrick(wav, f0, timeaxis, fs)</span><br><span class="line">ap = pyworld.d4c(wav, f0, timeaxis, fs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># f0, sp, ap = world.wav2world(x,sr,fftlen,frame_period)</span></span><br><span class="line">print(ap.shape)</span><br><span class="line">print(<span class="string">f"ap <span class="subst">&#123;np.isnan(ap).any()&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">wav = pyworld.synthesize(f0, sp, ap, fs, frame_period)</span><br><span class="line"><span class="comment"># wav = wav.astype(np.float32)</span></span><br><span class="line">soundfile.write(<span class="string">'test.wav'</span>, wav, fs)</span><br><span class="line"></span><br><span class="line">x, sr = soundfile.read(os.getcwd()+<span class="string">"/bed (537).wav"</span>)</span><br><span class="line"><span class="comment"># print(x[0].type)  # 'numpy.float64' object has no attribute 'type'</span></span><br><span class="line">f01, timeaxis1 = pyworld.harvest(x, sr, frame_period=frame_period, f0_floor=<span class="number">71.0</span>, f0_ceil=<span class="number">800.0</span>)</span><br><span class="line">sp1 = pyworld.cheaptrick(x, f01, timeaxis1, fs)</span><br><span class="line">ap1 = pyworld.d4c(x, f01, timeaxis1, fs)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">以上这样，直接用soundfile 读取成float64 数据，</span></span><br><span class="line"><span class="string">然后再直接用 soundfile.write 保存float64的文件 或者是 先转化成float32 再保存成文件， </span></span><br><span class="line"><span class="string">保存出来的文件再次用soundfile 读取出来，</span></span><br><span class="line"><span class="string">再次用测试ap是否有 nan值，都没有问题。</span></span><br><span class="line"><span class="string">综上，能用soundfile就避免用librosa，读取和写入文件都是这个道理；ßå</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'************'</span>)</span><br><span class="line">print(ap1.shape)</span><br><span class="line">print(<span class="string">f"ap1 <span class="subst">&#123;np.isnan(ap1).any()&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f"ap <span class="subst">&#123;np.isnan(ap).any()&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># # print(np.isnan(ap))</span></span><br><span class="line"><span class="comment"># t = ap</span></span><br><span class="line"><span class="comment"># t = t[np.isnan(t)]</span></span><br><span class="line"><span class="comment"># # t = t[np.where(np.isnan(t))]</span></span><br><span class="line"><span class="comment"># print(t.shape)</span></span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> ap:</span><br><span class="line">    <span class="comment"># if np.isnan(x):</span></span><br><span class="line">    count = count+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> np.isnan(ap).any():</span><br><span class="line"></span><br><span class="line">    f0, sp, ap = world.wav2world(np.absolute(x),fs,fftlen,frame_period)</span><br><span class="line">    print(<span class="string">f"ap abs <span class="subst">&#123;np.isnan(ap).any()&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">exit()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="-[语音]" scheme="http://yoursite.com/categories/%E8%AF%AD%E9%9F%B3/"/>
    
    
      <category term="语音" scheme="http://yoursite.com/tags/%E8%AF%AD%E9%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>关于 WORLD 中 code_spectral_envelope 和 MFCC 关系的理解</title>
    <link href="http://yoursite.com/2023/07/08/%E5%85%B3%E4%BA%8E%20WORLD%20%E4%B8%AD%20code_spectral_envelope%20%E5%92%8C%20MFCC%20%E5%85%B3%E7%B3%BB%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2023/07/08/%E5%85%B3%E4%BA%8E%20WORLD%20%E4%B8%AD%20code_spectral_envelope%20%E5%92%8C%20MFCC%20%E5%85%B3%E7%B3%BB%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2023-07-08T08:38:20.860Z</published>
    <updated>2020-08-17T11:49:01.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://github.com/mmorise/World/issues/90" target="_blank" rel="noopener">https://github.com/mmorise/World/issues/90</a> （有人提问 WORLD 提取得到的 mel spectrum 梅尔谱和传统概念上 经过一系列stft之后还要经过“三角滤波器组”的过程区别？）</li><li><a href="https://github.com/mmorise/World/issues/33" target="_blank" rel="noopener">https://github.com/mmorise/World/issues/33</a> （r9y9 在<a href="https://github.com/mmorise" target="_blank" rel="noopener">mmorise</a>/<strong><a href="https://github.com/mmorise/World" target="_blank" rel="noopener">World</a></strong> 下提问关于 编码/解码后音色变化问题；代码bug已解决；学习一下画图和使用特点）</li></ol><hr><a id="more"></a><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol><li><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200723190241.png" alt="image-20200723190240435"></p></li><li><p>简言之，传统论文  <a href="https://www.sp.nitech.ac.jp/~tokuda/selected_pub/pdf/conference/tokuda_icslp1994.pdf" target="_blank" rel="noopener">Mel-cepstral analysis</a> 提到的方法，也就是正常思路的经过 FFT 后再经过三角滤波器组 得到的 mel 谱，之所以需要三角滤波，可以理解为是，因为MFCC是在 <strong>频谱图</strong> 上进行的操作，所以是未经过 <strong>平滑</strong> 操作的，所以需要滤波器；</p></li><li><p>而WORLD，是在频谱包络上进行的操作，本身已经是顺滑过的，所以得到的 sp 特征，看似流程上没有三角滤波，但是它在使用的时候，效果和SPTK、librosa、merlin之类工具得到的 MFCC 来处理的音频效果是差不多的。</p></li><li><p>所以，就可以理解，很多论文的实现上，作者们在遇到：MFCC 这个特征需要时，若非论文着重强调，是可以用 <strong>code_spectral_envelope</strong> ，并取维度参数为 36 等，来表示36维度（bin）的MFCC特征的。</p></li></ol><hr><p>以上，解决了一直没人能帮我说清楚的问题疑惑。</p><p>还是要多看看源码和 issue，和大佬们交流才进步的多。</p><hr><p>这行里，可能大佬很多，但是能真正带领小白入门的系统专家真的少。sigh。我可能适合做老师，喜欢把大家难懂的东西，娓娓道来，教会孩子们。😁</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;参考：&quot;&gt;&lt;a href=&quot;#参考：&quot; class=&quot;headerlink&quot; title=&quot;参考：&quot;&gt;&lt;/a&gt;参考：&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mmorise/World/issues/90&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/mmorise/World/issues/90&lt;/a&gt; （有人提问 WORLD 提取得到的 mel spectrum 梅尔谱和传统概念上 经过一系列stft之后还要经过“三角滤波器组”的过程区别？）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mmorise/World/issues/33&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/mmorise/World/issues/33&lt;/a&gt; （r9y9 在&lt;a href=&quot;https://github.com/mmorise&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mmorise&lt;/a&gt;/&lt;strong&gt;&lt;a href=&quot;https://github.com/mmorise/World&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;World&lt;/a&gt;&lt;/strong&gt; 下提问关于 编码/解码后音色变化问题；代码bug已解决；学习一下画图和使用特点）&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="-[语音]" scheme="http://yoursite.com/categories/%E8%AF%AD%E9%9F%B3/"/>
    
    
      <category term="语音" scheme="http://yoursite.com/tags/%E8%AF%AD%E9%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2023/07/08/hello-world/"/>
    <id>http://yoursite.com/2023/07/08/hello-world/</id>
    <published>2023-07-08T08:38:20.854Z</published>
    <updated>2020-06-07T08:42:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Diffusion Model</title>
    <link href="http://yoursite.com/2023/07/08/Diffusion%20Model/"/>
    <id>http://yoursite.com/2023/07/08/Diffusion%20Model/</id>
    <published>2023-07-08T08:38:20.853Z</published>
    <updated>2022-06-08T14:22:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Diffussion Model——扩散概率模型</p><p>——适用于所有的生成类任务：TTS （☑️）、VC（❓）</p><p>——其实和VAE有点像：多层 VAE</p><hr><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605112436.png" alt="image-20220605112436197"></p><ul><li><p>最早见刊时间 1995-2004</p></li><li><p>论文：2015-ICML    &amp;&amp;    ==2020-NIPS==</p><ul><li>[1] Ho, Jonathan, Ajay Jain, and Pieter Abbeel. “Denoising diffusion probabilistic models.” <em>Advances in Neural Information Processing Systems</em> 33 (<strong>2020</strong>): 6840-6851.</li><li>[2] Sohl-Dickstein, Jascha, et al. “Deep unsupervised learning using nonequilibrium thermodynamics.” <em>International Conference on Machine Learning</em>. PMLR, <strong>2015.</strong></li></ul></li><li><p><a href="https://github.com/hojonathanho/diffusion" target="_blank" rel="noopener">github代码</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1b541197HX" target="_blank" rel="noopener">视频解读Bilibili</a></p></li></ul><ul><li><p>可参考解读阅读材料：</p><ul><li><a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/" target="_blank" rel="noopener">What are Diffusion Models?</a></li><li><a href="https://zhuanlan.zhihu.com/p/267696723" target="_blank" rel="noopener">基于扩散概率模型 (Diffusion Probabilistic Model ) 的音频生成模型</a></li><li><a href="https://www.birentech.com/news/114.html" target="_blank" rel="noopener"><strong>深度生成网络新思路：扩散概率模型</strong></a></li><li><a href="https://www.zhaoyabo.com/?p=7675" target="_blank" rel="noopener">概述|Diffusion Models扩散模型|学习笔记</a></li><li><a href="http://nooverfit.com/wp/%E5%9C%A8%E5%99%AA%E5%A3%B0%E4%B8%AD%E7%94%9F%E9%95%BF%EF%BC%9A%E6%89%A9%E6%95%A3%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8Bdiffusion-models%EF%BC%8Cscore-based-models%EF%BC%8C%E5%9F%BA/" target="_blank" rel="noopener">在噪声中“生长”：扩散生成模型(Diffusion Models)，score-based models，基于评分的生成模型</a></li><li><a href="https://zhuanlan.zhihu.com/p/500532271" target="_blank" rel="noopener">详解diffusion model-知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/366004028" target="_blank" rel="noopener">另辟蹊径—Denoising Diffusion Probabilistic 一种从噪音中剥离出图像/音频的模型</a></li></ul></li><li><p><a href="https://zhuanlan.zhihu.com/p/448575579" target="_blank" rel="noopener">简述马尔可夫链【通俗易懂】</a></p></li></ul><a id="more"></a><hr><ul><li>前置的数学知识</li></ul><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605143554.png" alt="image-20220605143554259"></p><ul><li>贝叶斯公式</li><li>VAE：KL散度</li></ul><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605144221.png" alt="image-20220605144221925">)<img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605151903.png" alt="image-20220605151903434"></p><ul><li>训练：x-&gt;z</li><li>推理：z-&gt;x</li><li>【联合概率分布】</li><li>训练目标：最大化“对数似然” log p(x)</li><li>分子分母同时乘上一个“后验分布” q</li><li><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605151544.png" alt="image-20220605151544252"></li></ul><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605151340.png" alt="image-20220605151340796">)<img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605151645.png" alt="image-20220605151645670"></p><ul><li><p>基于的是 Markvo 假设</p></li><li><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605152702.png" alt="image-20220605152702039"></p></li><li></li></ul><p>❤️思考：Diffusion &amp; Multi-VAE 的区别？</p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605152857.png" alt="image-20220605152857214"></p><ul><li><ol><li>X0-&gt;Xt 扩散过程：熵增</li><li>Xt-&gt;X0 逆扩散：去噪，还原</li><li>：对应的“条件概率分布”</li><li></li></ol></li></ul><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605153221.png" alt="image-20220605153221865"></p><ul><li>==正向过程不含参数，所有 均值、方差 都是确定的==，是一个 markvo链的关系。类比lr，固定不变</li><li>正向加噪的过程，是一个条件概率分布，而且是一个 高斯正太分布，均值为： “$<br>\sqrt{1-\beta_{t}} \mathbf{x}<em>{t-1}<br>$”，方差为 ：“$\beta</em>{t}$”</li><li>各向独立：“各向同性”</li></ul><p>🌟怎么算 X 呢？：</p><ul><li><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605154232.png" alt="image-20220605154232033"></p></li><li><p>然后可以套 Markvo 迭代，不断得到 Xt+1 … 更多采样值</p></li></ul><ul><li>问题： <ul><li>T 理论是 ∞ 无穷大，怎么设置？</li><li>参数化分布的 “$\beta_{t}$” （方差）应该怎么设置？</li></ul></li><li>$<br>\left{\beta_{t} \in(0,1)\right}_{t=1}^{t}<br>$</li><li>随着时间推移，$\beta_{t}$ 越来越大</li></ul><p>关于 T：参数重整化 算出来</p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605154836.png" alt="image-20220605154836448"></p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605180042.png" alt="image-20220605180041989"></p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220606000627.png" alt="image-20220606000627561"></p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605160908.png" alt="image-20220605160908387"></p><p>所以：</p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605161022.png" alt="image-20220605161022505"></p><ul><li><p>所以，时间取决于：最后的 均值、方差，接近于 “==各向同性==”的正态分布了：即==（0，1）==时，那么就可以说明 Xt “正向扩散过程”已经完全ok了，可以开始“逆扩散过程”了。</p></li><li><p>这其中，均值方差 alpha、beta （参数化正态分布时设置的）都是我们自己设定的，是个固定值，所以完全可控</p></li><li><p>总之：==正向扩散，想要得到“标准正态分布”==</p></li><li><p>一般原则：分布接近噪声时，beta 可以变大，刚开始时，beta 不要太大</p></li></ul><p>🌟逆扩散过程</p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605161617.png" alt="image-20220605161617915">)<img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605161825.png" alt="image-20220605161824972"></p><ul><li>逆扩散，仍然是一个 Markvo chain 过程</li><li>需要构建一个“==参数分布==”：不然直接从 Xt 到 X0 链式求取非常麻烦，所以需要构建一个网络</li><li>也是假设为一个 “高斯分布”</li><li><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605164735.png" alt="image-20220605164735409"></li><li>把问题转化为 （Xt，t）两个变量的关系网络，均值方差都是和（Xt，t）这两个相关</li><li><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605164854.png" alt="image-20220605164854035"></li></ul><ul><li><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605165014.png" alt="image-20220605165014152">：</li><li><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605165127.png" alt="image-20220605165127198"></li></ul><p>🌟说说怎么算：</p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605165947.png" alt="image-20220605165947867"></p><p>==》基于贝叶斯公式：</p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605165908.png" alt="image-20220605165908200"></p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605161903.png" alt="image-20220605161903503"></p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605161940.png" alt="image-20220605161940198">)<img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605162006.png" alt="image-20220605162006080"></p><hr><ul><li>图 1. 不同类型的生成模型概述。</li></ul><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605125755.png" alt="image-20220605125755791"></p><ol><li><h6 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h6><ul><li><em>扩散概率模型</em>( <a href="https://arxiv.org/abs/1503.03585" target="_blank" rel="noopener">Sohl-Dickstein et al., 2015</a> )</li><li><em>噪声条件评分网络</em>( <strong>NCSN</strong> ; <a href="https://arxiv.org/abs/1907.05600" target="_blank" rel="noopener">Yang &amp; Ermon, 2019</a> )</li><li><em>去噪扩散概率</em>模型 (<strong>DDPM</strong>; <a href="https://arxiv.org/abs/2006.11239" target="_blank" rel="noopener">Ho et al. 2020</a>).</li></ul></li></ol><ol start="2"><li><h6 id="快速总结"><a href="#快速总结" class="headerlink" title="快速总结"></a>快速总结</h6><ul><li><strong>优点</strong>：易处理性和灵活性是生成建模中两个相互冲突的目标。易于处理的模型可以进行分析评估并廉价地拟合数据（例如通过高斯或拉普拉斯），但它们不能轻易地描述丰富数据集中的结构。灵活的模型可以拟合数据中的任意结构，但从这些模型中评估、训练或采样通常很昂贵。<strong>扩散模型在分析上易于处理和灵活</strong></li><li><strong>缺点</strong>：扩散模型依赖于<strong>长马尔可夫扩散步骤链</strong>来生成样本，因此在<strong>时间和计算方面可能非常昂贵</strong>。已经提出了新的方法来使该过程更快，但<strong>采样仍然比 GAN 慢</strong>。</li></ul></li></ol><ol start="3"><li><p>谈谈马尔科夫：</p><ul><li>下一状态的概率分布只能由当前状态决定，在时间序列中它前面的事件均与之无关。这种特定类型的“<strong>无记忆性</strong> ”称作马尔可夫性质。</li><li><strong>转移概率矩阵</strong>：</li></ul><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605132903.jpg" alt="img"></p><p>上图中有 A 和 B 两个状态，A 到 A 的概率是 0.3，A 到 B 的概率是 0.7；B 到 B 的概率是 0.1，B 到 A 的概率是 0.9。</p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605132940.jpg" alt="img"></p></li></ol><ul><li><h6 id="状态转移矩阵-的稳定性"><a href="#状态转移矩阵-的稳定性" class="headerlink" title="==状态转移矩阵==的稳定性"></a>==<strong>状态转移矩阵</strong>==的稳定性</h6><p>状态转移矩阵有一个非常重要的特性，经过一定有限次数序列的转换，最终一定可以得到一个<strong>稳定的概率分布</strong> ，且与初始状态概率分布无关。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 状态转移矩阵</span></span><br><span class="line">matrix = np.matrix([[<span class="number">0.9</span>, <span class="number">0.075</span>, <span class="number">0.025</span>],</span><br><span class="line">                    [<span class="number">0.15</span>, <span class="number">0.8</span>, <span class="number">0.05</span>],</span><br><span class="line">                    [<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.5</span>]], dtype=float)</span><br><span class="line">vector1 = np.matrix([[<span class="number">0.3</span>, <span class="number">0.4</span>, <span class="number">0.3</span>]], dtype=float)</span><br><span class="line"><span class="comment">## 牛 熊 横盘</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    vector1 = vector1 * matrix</span><br><span class="line">    print(<span class="string">'Courrent round: &#123;&#125;'</span>.format(i+<span class="number">1</span>))</span><br><span class="line">    print(vector1)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Current round: 1</span><br><span class="line">[[ 0.405   0.4175  0.1775]]</span><br><span class="line">Current round: 2</span><br><span class="line">[[ 0.4715   0.40875  0.11975]]</span><br><span class="line">Current round: 3</span><br><span class="line">[[ 0.5156  0.3923  0.0921]]</span><br><span class="line">Current round: 4</span><br><span class="line">[[ 0.54591   0.375535  0.078555]]</span><br><span class="line">。。。。。。</span><br><span class="line">Current round: 58</span><br><span class="line">[[ 0.62499999  0.31250001  0.0625    ]]</span><br><span class="line">Current round: 59</span><br><span class="line">[[ 0.62499999  0.3125      0.0625    ]]</span><br><span class="line">Current round: 60</span><br><span class="line">[[ 0.625   0.3125  0.0625]]</span><br><span class="line">。。。。。。</span><br><span class="line">Current round: 99</span><br><span class="line">[[ 0.625   0.3125  0.0625]]</span><br><span class="line">Current round: 100</span><br><span class="line">[[ 0.625   0.3125  0.0625]]</span><br></pre></td></tr></table></figure><ul><li>n-gram 语音识别</li></ul><p>语言模型：N-Gram 是一种简单有效的语言模型，基于独立输入假设：<strong>第 n 个词的出现只与前面 N-1 个词相关，而与其它任何词都不相关</strong> 。整句出现的概率就是各个词出现概率的乘积。这些概率可以通过直接从语料中统计 N 个词同时出现的次数得到。</p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605134140.jpg" alt="img"></p><p>声学模型：利用 HMM 建模（隐马尔可夫模型），HMM 是指这一马尔可夫模型的内部状态外界不可见，外界只能看到各个时刻的输出值。对语音识别系统，输出值通常就是从各个帧计算而得的声学特征。</p><hr><p>Diffusion </p><ul><li>前向扩散（逐渐加噪声）</li><li>后向扩散（学会从带噪声数据中恢复内容信息）</li></ul><ol><li>高斯噪声：符合正态分布的噪声<ul><li>起伏噪声、宇宙噪声、热噪声和散粒噪声等等</li><li>N（μ，σ^2）</li><li>高斯分布函数<img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605134753.png" alt="image-20220605134753320" style="zoom:50%;"></li></ul></li></ol><ol start="2"><li><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605135130.png" alt="image-20220605135130047"></li></ol><ol start="3"><li><p>高斯分布</p><p>高斯分布可以写成以下形式：</p><pre><code>![[公式]](https://www.zhihu.com/equation?tex=%5Cmathcal+N%28x%7C%5Cmu%2C%5Csigma%5E2%29%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5Cpi%7D%5Csigma%7Dexp%5Cleft%28+-%5Cfrac%7B%28x-%5Cmu%29%5E2%7D%7B2%5Csigma%5E2%7D+%5Cright%29)</code></pre><p><img src="https://www.zhihu.com/equation?tex=%5Cmu" alt="[公式]"> 是均只期望， <img src="https://www.zhihu.com/equation?tex=%5Csigma%5E2" alt="[公式]"> 是方差，以上形式是基于只有一个变化维度的连续随机变量，因此以上又称为<strong>一元高斯分布</strong>。</p></li></ol><p>   当 <img src="https://www.zhihu.com/equation?tex=%5Cmathcal+N%28x%7C0%2C1%29%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5Cpi%7D%7Dexp%5Cleft%28+-%5Cfrac%7Bx%5E2%7D%7B2%7D+%5Cright%29" alt="[公式]">时，称为<strong>标准高斯分布</strong>（标准正态分布）：</p><p>   <img src="https://www.zhihu.com/equation?tex=%5Cmathcal+N%28x%7C0%2C1%29%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5Cpi%7D%7Dexp%5Cleft%28+-%5Cfrac%7Bx%5E2%7D%7B2%7D+%5Cright%29" alt="[公式]"></p><ol start="4"><li><p>当我们要对概率密度函数求值时，我们需要对σ平方并且取倒数。当我们需要经常对不同参数下的概率密度函数求值时，一种更高效的==<strong>参数化分布</strong>==的方式是==使用参数β∈(0,∞)==，来控制分布的精度(precision)(或方差的倒数)：</p><p>​                                                  $$\frac{1}{\sigma}=\sqrt{\beta} $$    </p></li></ol><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605140547.png" alt="img"></p><p>​        正态分布可以推广到Rn空间，这种情况下被称为多维正态分布(multivariate     normal distribution)。它的参数是一个正定对称矩阵∑：</p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605140834.png" alt="img"></p><p>参数μ仍然表示分布的均值，只不过现在是向量值。参数∑给出了分布的 ==<strong>协方差矩阵</strong>== 。和单变量的情况类似，当我们希望对很多不同参数下的概率密度函数多次求值时，协方差矩阵并不是一个很高效的参数化分布的方式，因为对概率密度函数求值时需要对∑求逆。我们可以使用一个<strong>精度矩阵</strong>(precision matrix)β进行替代：</p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605140921.png" alt="img"></p><p>我们常常把协方差矩阵固定成一个对角阵。一个更简单的版本是==各向同性(isotropic)高斯分布==，它的协方差矩阵是一个标量乘以单位阵。</p><ol start="5"><li></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Diffussion Model——扩散概率模型&lt;/p&gt;
&lt;p&gt;——适用于所有的生成类任务：TTS （☑️）、VC（❓）&lt;/p&gt;
&lt;p&gt;——其实和VAE有点像：多层 VAE&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220605112436.png&quot; alt=&quot;image-20220605112436197&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;最早见刊时间 1995-2004&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;论文：2015-ICML    &amp;amp;&amp;amp;    ==2020-NIPS==&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[1] Ho, Jonathan, Ajay Jain, and Pieter Abbeel. “Denoising diffusion probabilistic models.” &lt;em&gt;Advances in Neural Information Processing Systems&lt;/em&gt; 33 (&lt;strong&gt;2020&lt;/strong&gt;): 6840-6851.&lt;/li&gt;
&lt;li&gt;[2] Sohl-Dickstein, Jascha, et al. “Deep unsupervised learning using nonequilibrium thermodynamics.” &lt;em&gt;International Conference on Machine Learning&lt;/em&gt;. PMLR, &lt;strong&gt;2015.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/hojonathanho/diffusion&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github代码&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1b541197HX&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;视频解读Bilibili&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可参考解读阅读材料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://lilianweng.github.io/posts/2021-07-11-diffusion-models/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What are Diffusion Models?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/267696723&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;基于扩散概率模型 (Diffusion Probabilistic Model ) 的音频生成模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.birentech.com/news/114.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;深度生成网络新思路：扩散概率模型&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhaoyabo.com/?p=7675&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;概述|Diffusion Models扩散模型|学习笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://nooverfit.com/wp/%E5%9C%A8%E5%99%AA%E5%A3%B0%E4%B8%AD%E7%94%9F%E9%95%BF%EF%BC%9A%E6%89%A9%E6%95%A3%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8Bdiffusion-models%EF%BC%8Cscore-based-models%EF%BC%8C%E5%9F%BA/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在噪声中“生长”：扩散生成模型(Diffusion Models)，score-based models，基于评分的生成模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/500532271&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;详解diffusion model-知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/366004028&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;另辟蹊径—Denoising Diffusion Probabilistic 一种从噪音中剥离出图像/音频的模型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/448575579&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;简述马尔可夫链【通俗易懂】&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>67. 二进制求和</title>
    <link href="http://yoursite.com/2023/07/08/67.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/"/>
    <id>http://yoursite.com/2023/07/08/67.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</id>
    <published>2023-07-08T08:38:20.852Z</published>
    <updated>2024-09-21T15:12:02.916Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-一些新的知识点："><a href="#1-一些新的知识点：" class="headerlink" title="1.一些新的知识点："></a>1.一些新的知识点：</h1><a id="more"></a><ul><li>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</li></ul><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200626183450.png" alt="image-20200623191413447"></p><ul><li>“charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。”</li><li><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200626183451.png" alt="image-20200623191946701"></li><li>Java 的反转函数 reverse() 将字符串反转</li><li>string.reverse（）；</li><li><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200626183452.png" alt="image-20200623192245991"></li><li>位运算符：</li><li><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200626183453.png" alt="image-20200623193029996"></li><li>^ : 按位抑或：不进位的加法：</li></ul><h1 id="2-想法"><a href="#2-想法" class="headerlink" title="2.想法"></a>2.想法</h1><ul><li>突然看到string字符串求和，想起了以前的各种题目，但是很没有头绪；</li><li>印象中，都是用最笨的 <strong>数组</strong> 的方式来进行，从没有尝试过用string来进行处理；</li></ul><p>是个学习的机会；</p><hr><h1 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = Math.max(a.length(),b.length());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//string.charAt（）:寻找当前string在指定位置的 字符 char；</span></span><br><span class="line">            <span class="comment">// 细节： string.length() 需要用上括号！ 别忘记括号！</span></span><br><span class="line">            carry += i &lt; a.length()? (a.charAt(a.length() - <span class="number">1</span> - i) - <span class="string">'0'</span>) : <span class="number">0</span>;</span><br><span class="line">            carry += i &lt; b.length()? (b.charAt(b.length() - <span class="number">1</span> - i) - <span class="string">'0'</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            ans.append((<span class="keyword">char</span>)(carry % <span class="number">2</span> + <span class="string">'0'</span>));</span><br><span class="line">            carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ans.append(<span class="string">'1'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.reverse();<span class="comment">// 这个方法实现的功能是，将 StringBuffer 字符串进行反转！！！</span></span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">      <span class="comment">//因为是 StringBuffer 类型，而返回类型要求是 String，所以调用 toString（）方法；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-一些新的知识点：&quot;&gt;&lt;a href=&quot;#1-一些新的知识点：&quot; class=&quot;headerlink&quot; title=&quot;1.一些新的知识点：&quot;&gt;&lt;/a&gt;1.一些新的知识点：&lt;/h1&gt;
    
    </summary>
    
    
      <category term="-[Java, 算法] -[LeetCode]" scheme="http://yoursite.com/categories/Java-%E7%AE%97%E6%B3%95-LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>445.两数相加(顺) II &amp;&amp; 002(逆)</title>
    <link href="http://yoursite.com/2023/07/08/445.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%20II%20(%E9%A1%BA)%20&amp;&amp;%20001(%E9%80%86)/"/>
    <id>http://yoursite.com/2023/07/08/445.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%20II%20(%E9%A1%BA)%20&amp;&amp;%20001(%E9%80%86)/</id>
    <published>2023-07-08T08:38:20.851Z</published>
    <updated>2020-06-26T10:35:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-445题目"><a href="#1-445题目" class="headerlink" title="1.445题目"></a>1.<a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">445题目</a></h1><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200626183507.png" alt="image-20200623182854483"></p><h1 id="2-类型：链表-amp-amp-栈"><a href="#2-类型：链表-amp-amp-栈" class="headerlink" title="2.类型：链表 &amp;&amp; 栈"></a>2.类型：链表 &amp;&amp; 栈</h1><p>正序的数字链表，求和时希望从个位开始算（逆序算），所以应该想到利用 <strong>栈</strong>（FILO）</p><h1 id="3-与002区别："><a href="#3-与002区别：" class="headerlink" title="3.与002区别："></a>3.与002区别：</h1><ul><li><p>002采用的是直接逆序存储的数字链表，所以可以直接从数字的尾巴开始求和，另外增加一个 <strong>进位标志符号</strong> 就可以；</p></li><li></li></ul><hr><h1 id="4-代码-Java"><a href="#4-代码-Java" class="headerlink" title="4.代码 Java"></a>4.代码 Java</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">twoSum_445</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> val;</span><br><span class="line">         ListNode next;</span><br><span class="line">         ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">     * public class ListNode &#123;</span></span><br><span class="line"><span class="comment">     *     int val;</span></span><br><span class="line"><span class="comment">     *     ListNode next;</span></span><br><span class="line"><span class="comment">     *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>( l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack1.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack2.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;<span class="comment">//进位符号</span></span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.empty() || !stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = carry;</span><br><span class="line">            sum += stack1.isEmpty()? <span class="number">0</span>:stack1.pop();</span><br><span class="line">            sum += stack1.isEmpty()? <span class="number">0</span>:stack2.pop();</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            node.next = head;</span><br><span class="line">            head = node;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="5-比较-002-代码："><a href="#5-比较-002-代码：" class="headerlink" title="5.比较 002 代码："></a>5.比较 002 代码：</h1><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200626183508.png" alt="image-20200623182835143"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">twoSum_002</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这份写的更漂亮，更优美，学习一个！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> || q!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = (p != <span class="keyword">null</span>)? p.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = (q != <span class="keyword">null</span>)? q.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            <span class="keyword">if</span>(p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">            <span class="keyword">if</span>(q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个我自己写的，改了好多地方才对，细节很多</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumber_HSJ</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>)&#123;<span class="comment">//细节，不是 l1.next !!!</span></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            sum += carry;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( l1 != <span class="keyword">null</span>)</span><br><span class="line">                sum += l1.val;</span><br><span class="line">            <span class="keyword">if</span>( l2 != <span class="keyword">null</span>)</span><br><span class="line">                sum += l2.val;</span><br><span class="line"></span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            node.val = sum % <span class="number">10</span>;</span><br><span class="line">            curr.next = node;</span><br><span class="line">            curr = node;</span><br><span class="line"><span class="comment">//            node.next = head;</span></span><br><span class="line"><span class="comment">//            head = node;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="keyword">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="keyword">null</span>) l2 = l2.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;<span class="comment">//细节！</span></span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="-[Java, 算法] -[LeetCode]" scheme="http://yoursite.com/categories/Java-%E7%AE%97%E6%B3%95-LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>3. 无重复字符的 最长子串</title>
    <link href="http://yoursite.com/2023/07/08/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2023/07/08/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</id>
    <published>2023-07-08T08:38:20.850Z</published>
    <updated>2020-06-26T10:34:27.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-题目："><a href="#1-题目：" class="headerlink" title="1.题目："></a>1.题目：</h1><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200626183412.png" alt="image-20200624145409923"></p><h1 id="2-思路："><a href="#2-思路：" class="headerlink" title="2.思路："></a>2.思路：</h1><ul><li><p>见过了那么多 <strong>子串</strong> 系列的题目，这次一起做个总结吧；</p></li><li><p><a href="https://blog.csdn.net/qq_19446965/article/details/81668047" target="_blank" rel="noopener">最长子序列&amp;最长子串的题型汇总</a></p></li><li><p><a href="https://blog.csdn.net/wangdd_199326/article/details/76464333" target="_blank" rel="noopener">史上最全最丰富的“最长公共子序列”、“最长公共子串”问题的解法与思路</a></p></li><li></li></ul><h1 id="3-滑动窗口的概念："><a href="#3-滑动窗口的概念：" class="headerlink" title="3.滑动窗口的概念："></a>3.滑动窗口的概念：</h1><ul><li>利用 <strong>双指针</strong> 来实现；即左指针 表示窗口左边界，右指针 表示窗口右边界；</li><li>然后滑动，即意味着 <strong>有序地，左右指针移动</strong></li></ul><h1 id="4-判断重复字符："><a href="#4-判断重复字符：" class="headerlink" title="4.判断重复字符："></a>4.判断重复字符：</h1><ul><li>除了之前学到的 HashMap，还有一个 HashSet（集合）</li><li><a href="https://blog.csdn.net/chen213wb/article/details/84647179" target="_blank" rel="noopener">HashMap 和 Hash Set 的差别</a></li></ul><h1 id="5-代码："><a href="#5-代码：" class="headerlink" title="5.代码："></a>5.代码：</h1><h2 id="法一：用HashSet直接查（里面只存一个值对象）"><a href="#法一：用HashSet直接查（里面只存一个值对象）" class="headerlink" title="法一：用HashSet直接查（里面只存一个值对象）"></a>法一：用HashSet直接查（里面只存一个值对象）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 无重复字符的最长子串<span class="title">_3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//HashSet:记录每个字符是否出现过</span></span><br><span class="line">        Set&lt;Character&gt; occ = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        · set.remove()</span></span><br><span class="line"><span class="comment">        · set.add()</span></span><br><span class="line"><span class="comment">        · srt.contains()</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="comment">//对比：</span></span><br><span class="line"><span class="comment">//        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="keyword">int</span> rk = -<span class="number">1</span>,ans = <span class="number">0</span>;<span class="comment">//rk:右指针；</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;<span class="comment">//左指针右移</span></span><br><span class="line">                occ.remove(s.charAt(i-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.contains(s.charAt(rk+<span class="number">1</span>)))&#123;</span><br><span class="line">                occ.add(s.charAt(rk+<span class="number">1</span>));</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, rk - i + <span class="number">1</span>);<span class="comment">//返回最长的长度值；</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="法二：，更简洁的滑动"><a href="#法二：，更简洁的滑动" class="headerlink" title="法二：，更简洁的滑动"></a>法二：，<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-jie-suan-fa-3-wu-zhong-fu-zi-fu-de-zui-chang-z/" target="_blank" rel="noopener">更简洁的滑动</a></h2><h2 id="HashMap（Key，-Value）"><a href="#HashMap（Key，-Value）" class="headerlink" title="HashMap（Key， Value）"></a>HashMap（Key， Value）</h2><ul><li><p>标签：滑动窗口</p></li><li><p>暴力解法时间复杂度较高，会达到 O($N^2$)</p></li><li><p>故而采取滑动窗口的方法降低时间复杂度</p></li><li><p>定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复</p></li><li><p>我们定义不重复子串的开始位置为 start，结束位置为 end</p></li><li><p>随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符</p></li><li><p>无论是否更新 start，都会更新其 map 数据结构和结果 ans。</p></li><li><p>时间复杂度：O(n)</p></li><li><pre><code class="java"><span class="keyword">public</span> <span class="keyword">int</span> lengthOfLongestSubstring_滑动窗口(String s){  <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;  Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();  <span class="keyword">for</span>(<span class="keyword">int</span> end=<span class="number">0</span>,start=<span class="number">0</span>; end&lt;n; end++){    <span class="keyword">char</span> alpha = s.charAt(end);    <span class="keyword">if</span>(map.containsKey(alpha)){      start = Math.max(map.get(alpha), start);<span class="comment">//这个很重要</span>    }    <span class="comment">/*</span><span class="comment">    * if(map.containsKey(s.charAt(i)))</span><span class="comment">    * j = Math.max(map.get(s.charAt(i)),j);</span><span class="comment">    * 为什么有这个判断，是因为在滑动过程中会出现当前loop出现的重复元素之间的区间，</span><span class="comment">    * 可能还有其他元素也是重复的。</span><span class="comment">    * 如果仅仅 j =map.get(s.charAt(i)) </span><span class="comment">    * 则你会忽略两个重复元素之间还有的其他元素也是重复的，</span><span class="comment">    * 例如 a bba ，如果没有max，则答案会是3，因为最后一个a和前一个a的间距是3，</span><span class="comment">    * 不加max就考虑不到中间两个b也是重复的。）</span><span class="comment">    * */</span>    ans = Math.max(ans, end - start + <span class="number">1</span>);    map.put(s.charAt(end), end+<span class="number">1</span>);  }  <span class="keyword">return</span> ans;}&lt;!--￼<span class="number">1</span>--&gt;</code></pre></li><li><p>返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p></li><li><pre><code class="java"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span>;&lt;!--￼<span class="number">2</span>--&gt;</code></pre></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line"><span class="keyword">int</span> pos = s.indexOf(s.charAt(i),flag);</span><br><span class="line"><span class="keyword">if</span> (pos &lt; i) &#123;</span><br><span class="line"><span class="keyword">if</span> (length &gt; result) &#123;</span><br><span class="line">result = length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result &gt;= s.length() - pos - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">length = i - pos - <span class="number">1</span>;</span><br><span class="line">flag = pos + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">length++;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：VioletKiss</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/javati-jie-3wu-zhong-fu-zi-fu-de-zui-chang-zi-chua/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="-[Java, 算法] -[LeetCode]" scheme="http://yoursite.com/categories/Java-%E7%AE%97%E6%B3%95-LeetCode/"/>
    
    
      <category term="-[LeetCode] -[最长子串系列] -[滑动窗口]" scheme="http://yoursite.com/tags/LeetCode-%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E7%B3%BB%E5%88%97-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>16.最接近的三数之和 &amp;&amp; 数组排序（默认升）</title>
    <link href="http://yoursite.com/2023/07/08/16.%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%20&amp;&amp;%20%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%EF%BC%88%E9%BB%98%E8%AE%A4%E5%8D%87%EF%BC%89/"/>
    <id>http://yoursite.com/2023/07/08/16.%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%20&amp;&amp;%20%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%EF%BC%88%E9%BB%98%E8%AE%A4%E5%8D%87%EF%BC%89/</id>
    <published>2023-07-08T08:38:20.846Z</published>
    <updated>2020-06-26T10:34:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-知识点："><a href="#1-知识点：" class="headerlink" title="1.知识点："></a>1.知识点：</h1><ul><li>双指针</li><li>数组排序（默认升序）；自定义降序</li></ul><h1 id="2-排序代码"><a href="#2-排序代码" class="headerlink" title="2.排序代码"></a>2.排序代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Java 中 实现 数组的排序</span></span><br><span class="line"><span class="comment"> * 默认是 上升序列；</span></span><br><span class="line"><span class="comment"> * 若要 下降，则默认需要 Integer 或者 Float 等 "类"类型，不能使用基础类型；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 最接近的三数之和<span class="title">_16</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意，要想改变默认的排列顺序，不能使用基本类型（int,double, char）,而要使用它们对应的类</span></span><br><span class="line">        Integer[] arr = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">//定义一个自定义类MyComparator的对象</span></span><br><span class="line">      <span class="comment">//法一：实现降序；需要类型，不能是基础类型</span></span><br><span class="line"><span class="comment">//        Arrays.sort(arr,Collections.reverseOrder());</span></span><br><span class="line">      <span class="comment">//法二：实现降序</span></span><br><span class="line"><span class="comment">//        Arrays.sort(arr, (a,b) -&gt; (b - a));         </span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//法三：需要自己重写 Comparator</span></span><br><span class="line">        Comparator cmp = <span class="keyword">new</span> MyComparator();      </span><br><span class="line">        Arrays.sort(arr, cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : arr) &#123;</span><br><span class="line">            System.out.print(x + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若得到的是 int ，需要先手动转为 Integer 类型！</span></span><br><span class="line">        <span class="keyword">int</span> scores[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">89</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        Integer newScores[] = <span class="keyword">new</span> Integer [<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;scores.length;i++)&#123;</span><br><span class="line"><span class="comment">//            newScores[i]= new Integer(scores[i]);</span></span><br><span class="line">            newScores[i] = scores[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Arrays.sort(newScores,Collections.reverseOrder());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : newScores) &#123;</span><br><span class="line">            System.out.print(x + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Comparator接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//作用是检查下面的方法名是不是父类中所有的，也起到注释的作用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h2></li><li><pre><code class="java">Collections.reverseOrder()&lt;!--￼<span class="number">1</span>--&gt;* 道理同上</code></pre></li><li><pre><code class="java">自己重写 Comparator&lt;!--￼<span class="number">2</span>--&gt;才可以实现 用 <span class="keyword">int</span> 类型直接排序（默认是升序列）</code></pre></li><li><p>若要降序，基本都需要 Integer 类型；</p></li><li><p>若是 int 基础类型，那么需要手动 转换一下类型；</p></li></ul><hr><h1 id="3-题目："><a href="#3-题目：" class="headerlink" title="3.题目："></a>3.题目：</h1><h2 id="寻找数组中三个数字之和，要求和最接近于目标数值"><a href="#寻找数组中三个数字之和，要求和最接近于目标数值" class="headerlink" title="寻找数组中三个数字之和，要求和最接近于目标数值"></a>寻找数组中三个数字之和，要求和最接近于目标数值</h2><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200626183440.png" alt="image-20200624135415119"></p><ul><li><p>法一：暴力：O（$N^3$）</p></li><li><p>```java<br>//法一：暴力 O(n^3)<br> int best = 100000;<br> int diff = 100000;<br> for(int i=0;i&lt;nums.length;i++){</p><pre><code>for(int j = i+1;j&lt;nums.length;j++){    for(int k = j+1;k&lt;nums.length;k++){        if(Math.abs(nums[i]+nums[j]+nums[k] - target) &lt; diff){            diff = Math.abs(nums[i]+nums[j]+nums[k] - target);            best = nums[i]+nums[j]+nums[k];        }    }}</code></pre><p> }<br> return best;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* </span><br><span class="line"></span><br><span class="line">* 法二：双指针：第一个元素从头到尾遍历，二、三元素从表头、尾向中间靠拢。</span><br><span class="line"></span><br><span class="line">  * 好处是：省掉了很多没必要的不可能组合；（有点剪枝的意思了）</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class 最接近的三数之和_16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public int threeSumClosest(int[] nums, int target)&#123;</span><br><span class="line">        Arrays.sort(nums);&#x2F;&#x2F;升序排列</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        int best &#x3D; 10001000;</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0;i &lt; n; i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;若下一个元素和当前元素内容一样，则可以跳过；</span><br><span class="line">            &#x2F;&#x2F;continue，直接跳过当前循环，进入下一次循环；</span><br><span class="line">            if(i&gt;0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1])&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;使用双指针，枚举 b 和 c；</span><br><span class="line">            int j &#x3D; i+1, k &#x3D; n-1;</span><br><span class="line">            while(j &lt; k)&#123;</span><br><span class="line">                int sum &#x3D; nums[i] + nums[j] + nums[k];</span><br><span class="line">                &#x2F;&#x2F;如果直接等于target，那么直接返回，最接近；</span><br><span class="line">                if(sum &#x3D;&#x3D; target)&#123;</span><br><span class="line">                    return target;</span><br><span class="line">                &#125;</span><br><span class="line">                if(Math.abs(sum - target) &lt; Math.abs(best - target))&#123;</span><br><span class="line">                    best &#x3D; sum;</span><br><span class="line">                &#125;</span><br><span class="line">                if(sum &gt; target)&#123;</span><br><span class="line">                    int k0 &#x3D; k - 1;</span><br><span class="line">                    &#x2F;&#x2F;开始移动 c 的指针，直到比原本的 c 值要小；</span><br><span class="line">                    &#x2F;&#x2F; 向左移动到下一个不想等的元素；</span><br><span class="line">                    while(j &lt; k0 &amp;&amp; nums[k0] &#x3D;&#x3D; nums[k])&#123;</span><br><span class="line">                        --k0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    k &#x3D; k0;  &#x2F;&#x2F; 如果发生 k &#x3D; k0 &#x3D;&#x3D; j;那么会退出现在的 while(j &lt; k)</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    &#x2F;&#x2F;如果 sum &lt; target，那么就把 b 指针向左移动；</span><br><span class="line">                    int j0 &#x3D; j+1;</span><br><span class="line">                    while(j0 &lt; k &amp;&amp; nums[j0] &#x3D;&#x3D; nums[j])&#123;</span><br><span class="line">                        ++j0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j &#x3D; j0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return best;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="-[Java, 算法] -[LeetCode]" scheme="http://yoursite.com/categories/Java-%E7%AE%97%E6%B3%95-LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>445.两数相加(顺) II &amp;&amp; 002(逆)</title>
    <link href="http://yoursite.com/2023/07/08/1143.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2023/07/08/1143.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2023-07-08T08:38:20.845Z</published>
    <updated>2020-06-25T12:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-最长公共子序列："><a href="#1-最长公共子序列：" class="headerlink" title="1.最长公共子序列："></a>1.最长公共子序列：</h1><h2 id="最长公共子序列-LCS-Longest-Common-Subsequence"><a href="#最长公共子序列-LCS-Longest-Common-Subsequence" class="headerlink" title="最长公共子序列(LCS):Longest Common Subsequence"></a>最长公共子序列(LCS):<code>Longest Common Subsequence</code></h2><ul><li><p>对于两个子序列 S1 和 S2，找出它们最长的公共子序列。</p></li><li><p>定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况：</p></li></ul><ol><li>当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1。</li><li>当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }。</li><li>综上，最长公共子序列的状态转移方程为：</li></ol><p><img src="https://pic.leetcode-cn.com/d8555d9231c57efc399b47af4c358d43df0e45d71bc65a235479d9fb091d4af9-4c4ff66ed0decdde711678563728e0cf_ecd89a22-c075-4716-8423-e0ba89230e9a.jpg" alt="4c4ff66ed0decdde711678563728e0cf_ecd89a22-c075-4716-8423-e0ba89230e9a.jpg"></p><ul><li>对于长度为 N 的序列 S1 和长度为 M 的序列 S2，dp[N][M] 就是序列 S1 和序列 S2 的最长公共子序列长度。</li></ul><p>作者：bryank-3<br>链接：<a href="https://leetcode-cn.com/problems/longest-common-subsequence/solution/jian-dan-yi-dong-zui-chang-gong-gong-zi-xu-lie-by-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subsequence/solution/jian-dan-yi-dong-zui-chang-gong-gong-zi-xu-lie-by-/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h1 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = text1.length(), n2 = text2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">              dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-几种解法："><a href="#3-几种解法：" class="headerlink" title="3.几种解法："></a>3.几种解法：</h1><ol><li><h2 id="暴力递归（不用DP-Table）"><a href="#暴力递归（不用DP-Table）" class="headerlink" title="暴力递归（不用DP Table）"></a>暴力递归（不用DP Table）</h2></li></ol><ul><li>是 <strong>从后往前</strong> 比较计数的；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(str1, str2)</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        <span class="comment"># 空串的 base case</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">-1</span> <span class="keyword">or</span> j == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> str1[i] == str2[j]:</span><br><span class="line">            <span class="comment"># 这边找到一个 lcs 的元素，继续往前找</span></span><br><span class="line">            <span class="keyword">return</span> dp(i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 谁能让 lcs 最长，就听谁的</span></span><br><span class="line">            <span class="keyword">return</span> max(dp(i<span class="number">-1</span>, j), dp(i, j<span class="number">-1</span>))</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># i 和 j 初始化为最后一个索引</span></span><br><span class="line">    <span class="keyword">return</span> dp(len(str1)<span class="number">-1</span>, len(str2)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h2 id="2-法二，借用DP-Table来记录（也可用备忘录）"><a href="#2-法二，借用DP-Table来记录（也可用备忘录）" class="headerlink" title="2. 法二，借用DP Table来记录（也可用备忘录）"></a>2. 法二，借用DP Table来记录（也可用备忘录）</h2><ul><li>双层遍历：</li><li>判断：当前两个字符一样吗？<ul><li>一样：左斜上角空格数字（dp[i-1][i-1]） 加1;</li><li>不一样：比较 <strong>上</strong> &amp;&amp; <strong>下</strong> 的最大值，取大的那一个来填充当前dp[ i ][ j ]</li><li></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(str1, str2)</span> -&gt; int:</span></span><br><span class="line">    m, n = len(str1), len(str2)</span><br><span class="line">    <span class="comment"># 构建 DP table 和 base case</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># 进行状态转移</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 找到一个 lcs 中的字符</span></span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="3-优化：用动态数组（一维数组）来解决："><a href="#3-优化：用动态数组（一维数组）来解决：" class="headerlink" title="3. 优化：用动态数组（一维数组）来解决："></a>3. 优化：用动态数组（一维数组）来解决：</h2><ol><li>在利用二维dp数组记录dp[ i ][ j ]时，需要用到dp[ i-1 ][ j-1 ] (左上方),dp[ i-1 ][ j ] (上边),dp[ i ][ j-1 ] (左边)。</li><li>优化为滚动数组记录dp[ j ] (dp[ i ][ j ]) 时，dp[ j-1 ] ( i-1 ) 已被更新为dp[ j-1 ]（ i ），所以需定义变量last去记录未被更新前的dp[ j-1 ]（ i-1 ）;</li><li>所以计算dp[j]的当前值时，会用到last（dp[ i-1 ][ j-1 ]）、dp[ j ] (dp[ i-1 ][ j ])和dp[ j-1 ] (dp[ i ][ j-1 ]);<br><strong>注意：计算每一行的第一个元素时候，last需要初始化为0。</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=text1.size(),m=text2.size();</span><br><span class="line"><span class="keyword">int</span> dp[m+<span class="number">1</span>],last=<span class="number">0</span>,temp;</span><br><span class="line">fill(dp,dp+m+<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//fill(数组名，起始地【包括】，结束地【不包括】，填充值)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i,last=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">                temp=dp[j];</span><br><span class="line">   <span class="keyword">if</span>(text1[i-<span class="number">1</span>]==text2[j-<span class="number">1</span>])dp[j]=last+<span class="number">1</span>; </span><br><span class="line">   <span class="keyword">else</span> dp[j]=max(dp[j],dp[j-<span class="number">1</span>]);</span><br><span class="line">          last=temp;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><ul><li><strong>画一下流程图你就懂了</strong>，顺着 DP Table，按着上面的代码（一维数组）推一遍：</li><li><ol><li>先用 <strong>temp</strong> 保存当前节点，然后更新当前节点；</li><li>其中更新的时候，有两种情况：<ol><li>不相等：用 <strong>左边</strong> （体现在一维数组的前一个位置）和 <strong>上面</strong>（体现在一维数组的当前位置）进行比较，取更大的值来刷新当前节点（体现在一维数组当前的位置）</li><li>相等：用 <strong>last + 1</strong> ，其中 <strong>last</strong> 表征左上角（是在每一轮结束之后，把之前保存的 <strong>旧的</strong> <strong>当前位置值</strong> 给保存下来；从二位数组角度看来，就是左上角：因为 temp 下一轮已经右移，但是 last 还在上一个位置；）</li></ol></li><li>更新完当前节点位置数据之后，用 <strong>last</strong> 把当前的节点 旧的信息保存下来，last = temp，从二位数组角度看，就像是左上角数据；</li><li>然后循环1，2，3步骤</li></ol></li><li>注意，每一行结束更新之后，要把 <strong>last</strong> 重新归零！相当于 左上角数据从零开始重新移动（默认第零行、第零列 全为零）</li><li><img src="https://pic.leetcode-cn.com/5722d0bb29dfdf4ba276424fa0901b49ac69a75b32cb009514dca50e2a43c1c4-file_1578114778808" alt="img"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="-[Java, 算法] -[LeetCode]" scheme="http://yoursite.com/categories/Java-%E7%AE%97%E6%B3%95-LeetCode/"/>
    
    
      <category term="-[LeetCode] -[动态规划]" scheme="http://yoursite.com/tags/LeetCode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>139. 单词拆分</title>
    <link href="http://yoursite.com/2023/07/08/139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <id>http://yoursite.com/2023/07/08/139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</id>
    <published>2023-07-08T08:38:20.845Z</published>
    <updated>2020-06-26T05:46:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-解题思路："><a href="#1-解题思路：" class="headerlink" title="1.解题思路："></a>1.解题思路：</h1><ul><li>动态规划听上去非常高大上，但是其实都是源自于一个很自然的想法，就拿这道题来说，假如需要判断”onetwothreefour”这一个字符串能不能满足条件，我们很自然的想法就是：</li><li>如果”onetwothree”这一段可以拆分，再加上four如果也可以，那不就行了；</li><li>或者</li><li>如果”onetwothre”这一段可以拆分，再加上efour如果也可以，那不就行了；</li><li>这其实已经抓住了动态规划的最核心的东西了，换成式子来表达，就是</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="string">"onetwothreefour"</span>] = dp[<span class="string">"onetwothree"</span>这一段] &amp;&amp; 判断一下<span class="string">"four"</span></span><br><span class="line">dp[<span class="string">"onetwothreefour"</span>] = dp[<span class="string">"onetwothre"</span>这一段] &amp;&amp; 判断一下<span class="string">"efour"</span></span><br></pre></td></tr></table></figure><h1 id="2-代码："><a href="#2-代码：" class="headerlink" title="2.代码："></a>2.代码：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 单词拆分<span class="title">_139</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//Java boolean数组默认值为False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将List中单词放进 HashMap</span></span><br><span class="line">        <span class="keyword">for</span>(String word:wordDict)&#123;</span><br><span class="line">            map.put(word, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * public String substring(int beginIndex, int endIndex)</span></span><br><span class="line"><span class="comment">        * beginIndex -- 起始索引（包括）, 索引从 0 开始</span></span><br><span class="line"><span class="comment">        * endIndex -- 结束索引（不包括）</span></span><br><span class="line"><span class="comment">        * 索引：读取数组时的下标</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                dp[i] = dp[j] &amp;&amp; check(s.substring(j, i));</span><br><span class="line">                <span class="keyword">if</span>(dp[i]) <span class="keyword">break</span>;<span class="comment">//这句也很精髓</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.getOrDefault(s, <span class="keyword">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-Refrence"><a href="#3-Refrence" class="headerlink" title="3.Refrence"></a>3.<a href="https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-ju-jue-zhuang-xcong-jian-dan-de-xi/" target="_blank" rel="noopener">Refrence</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="-[Java, 算法] -[LeetCode]" scheme="http://yoursite.com/categories/Java-%E7%AE%97%E6%B3%95-LeetCode/"/>
    
    
      <category term="-[LeetCode] -[动态规划]" scheme="http://yoursite.com/tags/LeetCode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>1.两数之和</title>
    <link href="http://yoursite.com/2023/07/08/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2023/07/08/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2023-07-08T08:38:20.843Z</published>
    <updated>2020-06-26T10:32:55.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200626183100.jpg" alt="img"></p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200626183108.png" alt="image-20200621235419362"></p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200626183128.png" alt="image-20200621235438971"></p><h1 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1. HashMap"></a>1. HashMap</h1><ul><li>发现很多接发都用到了map，其中C++的vector容器，java是HashMap</li><li>涉及到之前数据结构盲区 <strong>红黑树</strong> <a href="https://www.cnblogs.com/shoulinniao/p/11966194.html" target="_blank" rel="noopener">https://www.cnblogs.com/shoulinniao/p/11966194.html</a></li><li></li></ul><hr><h1 id="2-《Java核心技术卷一》P372，chap9-3：映射"><a href="#2-《Java核心技术卷一》P372，chap9-3：映射" class="headerlink" title="2.《Java核心技术卷一》P372，chap9.3：映射"></a>2.《Java核心技术卷一》P372，chap9.3：映射</h1><ul><li>映射 <strong>MAP</strong> 数据结构= 「HashMap」&amp;&amp;「TreeMap」</li><li>存放 {键<strong>KEY</strong>：值<strong>VALUE</strong>}对</li><li>都只对 <strong>键（KEY）</strong>进行处理（ <strong>散列</strong>&amp;&amp; <strong>搜索树排序</strong>  ）</li></ul><h1 id="3-相关方法函数："><a href="#3-相关方法函数：" class="headerlink" title="3.相关方法函数："></a>3.相关方法函数：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希map初始化，自己定义Key和Value的类型</span></span><br><span class="line">Map&lt;String, Employee&gt; staff = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个employee对象，用作Value</span></span><br><span class="line">Employee harry = <span class="keyword">new</span> Employee(<span class="string">"Harry Hacker"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.：map.put（key，value）方法：将 键值对 放进HashMap</span></span><br><span class="line">staff.put(<span class="string">"123456"</span>,harry)<span class="comment">//</span></span><br><span class="line"><span class="comment">//同一个key存两次，会覆盖，并且返回的是上一次存储的 Value值；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.：map.get(key) 方法：按照 Key 的值，来从HashMap中获取Value</span></span><br><span class="line">String id = <span class="string">"123456"</span>;</span><br><span class="line">Employee e = staff.get(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//get()方法还可以人为设置默认值：</span></span><br><span class="line">Map&lt;String, Integer&gt; score = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> score = score.get(id,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//放这个Key对应的Value不存在时，返回 0；</span></span><br></pre></td></tr></table></figure><ul><li><ol><li><strong>import</strong> java.util.HashMap;//导入</li><li><strong>HashMap&lt;K, V&gt; map = new HashMap&lt;K, V&gt;（）;</strong>//定义map，K和V是类，<strong><em>不允许是基本类型？</em></strong></li><li><strong>put（K， V）</strong></li><li><strong>V get（K）</strong></li><li><strong>V remove（K）</strong>//移除K键的值，返回的是V，可以不接收</li><li><strong>size（）</strong>//返回映射Map中的元素数目</li><li><strong>replace（）</strong>//替换</li></ol></li><li><pre><code class="java"> map.replace( Key,Value );&lt;!--￼<span class="number">1</span>--&gt;</code></pre></li><li><p><strong>9. computeIfAbsent（）</strong>//</p></li><li><pre><code class="java"><span class="comment">//如果key键为java的,就添加，并且value为key键的长度</span><span class="comment">//这个算子就是一个和put功能差不多的算子，都是往map里面添加数据。</span>map.computeIfAbsent(<span class="string">"java"</span>, (key)-&gt;((String)key).length());&lt;!--￼<span class="number">2</span>--&gt;</code></pre></li><li></li></ul><hr><h1 id="4-关于遍历方法："><a href="#4-关于遍历方法：" class="headerlink" title="4.关于遍历方法："></a>4.关于遍历方法：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回所有 Key-Value 对：</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry n: map.entrySet())&#123;</span><br><span class="line">System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回所有 Key：</span></span><br><span class="line"><span class="keyword">for</span>(String n : map.keySet())&#123;</span><br><span class="line">System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回所有Value：</span></span><br><span class="line"><span class="keyword">for</span>(Integer n: map.values())&#123;</span><br><span class="line">System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="5-其他："><a href="#5-其他：" class="headerlink" title="5.其他："></a>5.其他：</h1><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200626183135.png" alt="image-20200622181415228"></p><ul><li><h2 id="HashMap中链表转换成红黑树的操作——treeifyBin"><a href="#HashMap中链表转换成红黑树的操作——treeifyBin" class="headerlink" title="HashMap中链表转换成红黑树的操作——treeifyBin()"></a>HashMap中链表转换成红黑树的操作——treeifyBin()</h2></li><li><p><a href="https://www.jianshu.com/p/309ea054cbc9" target="_blank" rel="noopener">https://www.jianshu.com/p/309ea054cbc9</a></p></li></ul><hr><h1 id="6-整理下HashMap里面的常见面试考点："><a href="#6-整理下HashMap里面的常见面试考点：" class="headerlink" title="6.整理下HashMap里面的常见面试考点："></a>6.整理下HashMap里面的常见面试考点：</h1><ol><li><h2 id="HashMap-默认容量："><a href="#HashMap-默认容量：" class="headerlink" title="HashMap 默认容量："></a>HashMap 默认容量：</h2><ul><li><strong>默认容量是：16 = 1 &lt;&lt; 4（位移动 = $1000_2$ =  $16_{10}$）；</strong></li><li><strong>默认负载因子是：0.75（根据）</strong>（服从泊松分布）：红黑树部分也是这个原理：</li><li>桶中的节点个数服从泊松分布；</li><li>取 $\lambda = 0.5$ ，此时 ，每个捅中元素个数为 【0，8】个的概率分别如图所示，大于八个，基本已经到达百万分之一的级别，所以 <strong>Java8</strong> 中选择以 <strong>8</strong> 作为一个临界数字，来决定是否将链表转化为 <strong>红黑树</strong>；</li><li>其中，在 最大桶元素个数 = 7 时，不变，作为缓冲，以防止过于频繁的转换消耗；  </li></ul><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200626183233.png" alt="image-20200622234017327"></p></li><li><h2 id="如何扩容？"><a href="#如何扩容？" class="headerlink" title="如何扩容？"></a>如何扩容？</h2><ul><li>$2^n$ 的形式，每次翻两倍；（这和 Hash 的工作机制有关：（n - 1）&amp; hash）</li><li>这样子的好处是，（$2^n$-1）= 一个全为1 的二进制树，计算更快；</li></ul></li><li><h2 id="为什么HashMap的数组大小一定要是-2-的幂？"><a href="#为什么HashMap的数组大小一定要是-2-的幂？" class="headerlink" title="为什么HashMap的数组大小一定要是 2 的幂？"></a>为什么<strong>HashMap</strong>的数组大小一定要是 2 的幂？</h2><ul><li><p>和 Hash 的工作机制有关；HashMap求索引时用&amp;运算,index=(n-1)&amp;hash</p></li><li><p>n = length : 表长度 = $2^n$ </p></li><li><p>（HashTable求索引用模运算，index = (hash &amp; 0x7FFFFFFF) % n）</p></li><li></li><li><p>：只有这样才能保证 经过 ( $2^n $ ) 操作后得到全是1 的值；</p></li><li><p>然后这样才能经过非常快速的位运算，快速拿到数组下标，并且能保证分布均匀</p></li><li><p>若不是 $2^n$, 则运算过后，会有0存在，那么就会导致，不管 和他进行按位与 运算的数字是多少，都会出现某些位永远是 0，那么就会导致，某些 <strong>桶</strong> 里的元素永远都是 <strong>0个</strong>，不均匀且不合理； </p></li></ul></li><li><h2 id="HashMap-为什么是线程不安全的？"><a href="#HashMap-为什么是线程不安全的？" class="headerlink" title="HashMap 为什么是线程不安全的？"></a>HashMap 为什么是线程不安全的？</h2><ul><li>在接近临界点时，若此时两个或者多个线程进行put操作，都会进行resize（扩容）和reHash（为key重新计算所在位置），而reHash在并发的情况下可能会形成<code>链表环</code>。</li><li>总结来说就是在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。</li><li>为什么在并发执行put操作会引起死循环？是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</li><li>jdk1.7的情况下，并发扩容时容易形成链表环，此情况在1.8时就好太多太多了。</li><li>因为在1.8中当链表长度达到阈值（默认长度为8）时，链表会被改成树形（红黑树）结构。如果删剩节点变成7个并不会退回链表，而是保持不变，删剩6个时就会变回链表，7不变是缓冲，防止频繁变换。</li><li>在JDK1.7中，当并发执行扩容操作时会造成环形链和数据丢失的情况。</li><li>在JDK1.8中，在并发执行put操作时会发生数据覆盖的情况。</li></ul></li><li><h2 id="Java-7-到-8-做了哪些改进？为什么？"><a href="#Java-7-到-8-做了哪些改进？为什么？" class="headerlink" title="Java 7 到 8 做了哪些改进？为什么？"></a>Java 7 到 8 做了哪些改进？为什么？</h2><ul><li>如上题所述：</li></ul></li></ol><hr><h1 id="7-拓展"><a href="#7-拓展" class="headerlink" title="7.拓展"></a>7.拓展</h1><ol><li><p>你能想到的做 HashMap 匹配的方法？ </p><ul><li><ol><li>直接取模：（$-2^{31}$ ~ $2^{31} -1$ ）% n = （0 , $n-1$）</li></ol></li><li>缺点：两个：<ul><li>负数对 n求余，答案是负数；（所以需要额外把 负数 变为 正数 ）</li><li>速度较慢（相比于位运算）：因为硬件中“求余”的本质是“除法”</li></ul></li></ul></li><li><p>常考的“坑”：扩容：<strong>resize（）</strong></p><ol><li>扩容 <strong>resize( )</strong>包括 <strong>rehash ( )</strong></li><li>机制是，当原来的容器中，容量达到了 <strong>0.75 * capacity</strong>， 再创建一个 <strong>2 * capacity</strong> 的新的桶；</li><li>然后会把旧的桶中的数据 <strong>迁移</strong> 过去，迁移的时候，伴随着重新地对原始数据进行 <strong>rehash</strong> 计算；</li><li><strong>resize（）</strong>里面的 <strong>transfer（）</strong>是一切问题的根源！！</li></ol></li><li><ul><li><strong>死锁问题：</strong>：本身是线程不安全的；完全是用户的问题；</li></ul></li><li><ul><li><strong>哈希表最致命的缺陷：哈希碰撞——&gt;</strong>最差情况下，会变成单链表；链表性能退化</li></ul></li><li><ul><li>所以在java7时代的 <strong>Tomcat（2011）</strong> 中引起了问题——&gt;可以通过一组精心设计的 恶意请求，造成 <strong>DoS（Deny of serveice）</strong></li></ul></li><li><pre><code>&quot;Aa&quot;,&quot;BB&quot;,&quot;C#&quot; 的哈希值是相同的！<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. ![image-20200622231322114](https:&#x2F;&#x2F;blog-1301959139.cos.ap-beijing.myqcloud.com&#x2F;picGo&#x2F;20200626183234.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 8. Java8的改进点 &amp;&amp; 新API</span><br><span class="line"></span><br><span class="line">1. 从 **数组 + 链表**——&gt;**数组 + 链表 &#x2F; 红黑树**</span><br><span class="line"></span><br><span class="line">2. 扩容时，插入顺序的改进：（原来是，从旧的头先取，然后按照“头插法”插入新的桶，导致顺序不稳定）</span><br><span class="line"></span><br><span class="line">3. 函数方法：（java 8 引入了 Lamda 表达式）</span><br><span class="line"></span><br><span class="line">   1. forEach</span><br><span class="line">   2. compute 系列</span><br><span class="line"></span><br><span class="line">4.  Map 的新 API</span><br><span class="line"></span><br><span class="line">   1. Merge</span><br><span class="line">   2. replace</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   ***</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   # 9.补充</span><br><span class="line"></span><br><span class="line">   1. **抑或运算**：可以更简单地理解为 **不进位的 加法 ！**</span><br><span class="line">   2. 红黑树转换，并不是要把整张表都从链表改成红黑树，而是只要 超过 8 个元素的 那个桶，改一下形式，就行了：</span><br><span class="line">   3. ![image-20200623000116947](https:&#x2F;&#x2F;blog-1301959139.cos.ap-beijing.myqcloud.com&#x2F;picGo&#x2F;20200626183235.png)</span><br><span class="line">   4. 二叉平衡树，平均查找时间：O（$log N$）</span><br><span class="line">   5. 单纯的二叉树，有个极端情况：插入顺序是有序的，那么就会造成演化成 **单链表**</span><br><span class="line">   6. 而红黑树，经过一定的旋转，保证了查找的效率（具体再仔细看看书）</span><br><span class="line">   7. **新的 Java8 中的 resize（）函数**：改进成了 **扩容时** 能保持原来的顺序，但是仍然不能保证 **线程安全**，只能说是大搭建撒后了线程冲突的概率。</span><br><span class="line">   8. 所以未来可能不会再多线程情况下遇到问题，但是还是不能放心地在多线程环境下使用它！（**Linux中的任务调度 是多线程的，有用到 HashMap**）</span><br><span class="line">   9. **HashCode** ： 默认使用 **32位** 的 **Int** 的**HashCode**；</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   ***</span><br><span class="line"></span><br><span class="line">   # 10.面试题常见：</span><br><span class="line"></span><br><span class="line">   1. 为什么用 数组 +链表：经典的学院派操作</span><br><span class="line">   2. Hash 冲突你还知道哪些解决办法：可以在冲突的桶里面，再套一层 Hash 表；即，冲突的进行二次分流；（表中再有个表）</span><br><span class="line">   3. 用Lin课的Li身体代替数组结构可以吗？：不可以，数组的随机访问是 O（1）的，不受数组长度的影响，二链表的顺序访问速度是 O（n），不能起到随机访问的效果；</span><br><span class="line">   4. get（）的操作？：如果第一个元素就是要求的话，那么就直接返回它；不是的话，那么，先判断该桶是什么结构，如果是红黑树，那么就用树的查找方法 查找；否则若是链表结构，就采用链表的顺序访问形式访问</span><br><span class="line">   5. 为什么 String 、Integer 这样的 wrapper 类 适合作为键？：因为String是final，具有不变性，而且已经重写了 equals（）和hashcode（）方法了。不变性是必要的！因为 为了要计算 hashcode（），就要防止键改变，如果键再嵌入时和获取时返回不同的 hashcode 的话，就不能从 HashMap 中找到你想要的对象。</span><br><span class="line">   6. 如果HashMap的大小超过了负载因子（load factor）定义的容量怎么办？：扩容：resize（） &amp; rehash（）「注意，resize（）的效率非常低！！！」所以如果预先知道有一个很大的表要创建，那么可以预先再创建时，就指定一个较大的空间，相当于时 **空间换时间**；避免未来的频繁resize（）花费很多时间。</span><br><span class="line"></span><br><span class="line">   ## </span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 11.红黑树：自己补充</span><br><span class="line"></span><br><span class="line">![截屏2020-06-23上午12.50.42](&#x2F;Users&#x2F;huangshengjie&#x2F;Desktop&#x2F;截屏2020-06-23上午12.50.42.png)</span><br><span class="line"></span><br><span class="line">* [B站课程](https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1tE411f7tP?from&#x3D;search&amp;seid&#x3D;2421763921920035607)：</span><br><span class="line">* [一份链接文章](https:&#x2F;&#x2F;blog.csdn.net&#x2F;Mr_Helloworld_&#x2F;article&#x2F;details&#x2F;106694724)</span><br><span class="line">* ![image-20200624005349275](https:&#x2F;&#x2F;blog-1301959139.cos.ap-beijing.myqcloud.com&#x2F;picGo&#x2F;20200626183236.png)</span><br><span class="line">* ![image-20200624005402070](https:&#x2F;&#x2F;blog-1301959139.cos.ap-beijing.myqcloud.com&#x2F;picGo&#x2F;20200626183237.png)</span><br><span class="line">* ![image-20200624005251467](https:&#x2F;&#x2F;blog-1301959139.cos.ap-beijing.myqcloud.com&#x2F;picGo&#x2F;20200626183238.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line"># 12.正题：001:两数之和：Java版</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class twoSum_001 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;暴力法</span><br><span class="line">    public int[] twoSum_force(int[] nums, int target)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt; nums.length;i++)&#123;</span><br><span class="line">            for(int j&#x3D;i+1;j&lt; nums.length;j++)&#123;</span><br><span class="line">                if(nums[j] &#x3D;&#x3D; target - nums[i])&#123;</span><br><span class="line">                    return new int[] &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(&quot;No two sum soluition&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;两遍 Hash，一遍存，一遍查取；</span><br><span class="line">    public int[] twoSum_HashTwice(int[] nums, int target)&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for(int i&#x3D;0;i&lt; nums.length;i++)&#123;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0; i&lt;nums.length;i++)&#123;</span><br><span class="line">            int complement &#x3D; target - nums[i];</span><br><span class="line">            if(map.containsKey(complement) &amp;&amp; map.get(complement) !&#x3D; i)&#123;</span><br><span class="line">                return new int[]&#123;i,map.get(complement)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(&quot;No two sum solution&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;一遍 Hash，先查，查不到就接着存；</span><br><span class="line">    public int[] twoSum_HashOnce(int[] nums, int target)&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            int complemenmt &#x3D; target - nums[i];</span><br><span class="line">            if(map.containsKey(complemenmt))&#123;</span><br><span class="line">                return new int[]&#123;i,map.get(complemenmt)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(&quot;No two sum solution.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="-[Java, 算法] -[LeetCode]" scheme="http://yoursite.com/categories/Java-%E7%AE%97%E6%B3%95-LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>语音赛道产业版图</title>
    <link href="http://yoursite.com/2022/06/17/%E8%AF%AD%E9%9F%B3%E8%B5%9B%E9%81%93%E4%BA%A7%E4%B8%9A%E7%89%88%E5%9B%BE/"/>
    <id>http://yoursite.com/2022/06/17/%E8%AF%AD%E9%9F%B3%E8%B5%9B%E9%81%93%E4%BA%A7%E4%B8%9A%E7%89%88%E5%9B%BE/</id>
    <published>2022-06-17T06:02:18.000Z</published>
    <updated>2022-06-17T06:07:57.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20220617140240.png" alt="image-20220617140240495"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>《AiShell3》</title>
    <link href="http://yoursite.com/2020/11/08/1108%E7%BB%84%E4%BC%9A%EF%BC%9A/"/>
    <id>http://yoursite.com/2020/11/08/1108%E7%BB%84%E4%BC%9A%EF%BC%9A/</id>
    <published>2020-11-08T07:16:54.000Z</published>
    <updated>2020-11-10T05:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><a id="more"></a><h2 id="1108组会："><a href="#1108组会：" class="headerlink" title="1108组会："></a>1108组会：</h2><ul><li><input checked disabled type="checkbox"> <p>完成<strong>软著申请</strong></p></li><li><input checked disabled type="checkbox"> <p>完成 <strong>开题PPT 修改</strong></p></li><li><input checked disabled type="checkbox"> <p>完成 VC综述 <strong>论文整理</strong></p></li><li><input disabled type="checkbox"> <p><strong>尚未完成</strong> 开题综述 <strong>主体部分</strong>（花了较多时间看<strong>格式处理</strong>）</p></li><li><input checked disabled type="checkbox"> <p>阅读<strong>《AiShell-3》</strong>论文：值得分享一个亮点（speaker-embedding-cycle-consistence Loss）</p></li></ul><hr><ul><li><a href="https://github.com/sos1sos2Sixteen/aishell-3-baseline-fc" target="_blank" rel="noopener">源码</a></li><li><a href="https://sos1sos2sixteen.github.io/aishell3/" target="_blank" rel="noopener">Demo</a></li><li></li></ul><p><strong>Boild-polit</strong> 数据集在15043上有？</p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201108153939.png" alt="image-20201108153938426"></p><hr><ul><li><p>前端：Tacotron</p></li><li><p>后端：MelGAN</p></li><li><p>🌟特点：在多说话人合成任务上，为了进一步增加相似度，提出了“<strong>speaker identity feedback constraint</strong>”</p></li><li><p>公式上体现：</p><ul><li><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201108153544.png" alt="image-20201108153543937"></li></ul></li><li><p><strong>部分</strong>，先<strong>预训练</strong>，然后在训练 <strong>Tacotron</strong> 的时候参数<strong>不再参与训练</strong> <strong>Frozen</strong></p></li></ul><hr><h2 id="另一些亮点："><a href="#另一些亮点：" class="headerlink" title="另一些亮点："></a>另一些亮点：</h2><ol><li><p>Tacotron2 中，对长序列语音的合成，表现乏力；</p><ul><li><p>通常改进方法是：从 <strong>hybrid-attention mechanism</strong> 改进为 <strong>purely location-based attention mechanisms</strong> ，即 Attention 机制的改进</p></li><li><p>但是这么弄，会使得 长句子的 韵律表现很差</p></li><li><p>本文转用 <strong>data augmentation</strong> <strong>数据增强</strong> 来处理长句子合成问题</p></li><li><p>扩充后的数据用于<strong>微调收敛于原始数据集</strong>的<strong>TTS模型</strong>。</p></li></ul></li><li><p>在语音合成任务中，之前较少看见 VAD 操作，一般在识别任务上用的比较多；</p><ul><li>本文在数据预处理上，用 基于能量谱的 VAD 来对训练集 语音开始部分的静音帧进行去除</li><li>帮助加速后续的 <strong>优化对齐环节</strong> </li></ul></li><li></li></ol><hr><p>🌟备注：</p><ol><li>在公司里 &amp;&amp; VCC2020中，很多队伍提到，用 <strong>24k</strong> 的生成效果比 <strong>16k</strong> 提升显著，本文是用<strong>16k</strong>，之后可从这个点做稍微提升</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="论文阅读笔记" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="VC" scheme="http://yoursite.com/tags/VC/"/>
    
      <category term="论文阅读笔记" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>1103——WaveNet &amp; 机器学习 考点小结</title>
    <link href="http://yoursite.com/2020/11/03/WaveNet%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2020/11/03/WaveNet%E5%B0%8F%E7%BB%93/</id>
    <published>2020-11-03T07:20:58.000Z</published>
    <updated>2020-11-03T08:01:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="WaveNet小结"><a href="#WaveNet小结" class="headerlink" title="WaveNet小结"></a>WaveNet小结</h2><a id="more"></a><ol><li><h4 id="WaveNet-一种语音合成的模型-https-www-pianshen-com-article-43431455160-image-20201016164508908-https-blog-1301959139-cos-ap-beijing-myqcloud-com-picGo-20201016164510-png"><a href="#WaveNet-一种语音合成的模型-https-www-pianshen-com-article-43431455160-image-20201016164508908-https-blog-1301959139-cos-ap-beijing-myqcloud-com-picGo-20201016164510-png" class="headerlink" title="WaveNet:一种语音合成的模型 https://www.pianshen.com/article/43431455160/![image-20201016164508908](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201016164510.png)"></a>WaveNet:一种语音合成的模型 <a href="https://www.pianshen.com/article/43431455160/![image-20201016164508908](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201016164510.png)" target="_blank" rel="noopener">https://www.pianshen.com/article/43431455160/![image-20201016164508908](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201016164510.png)</a></h4></li><li><h3 id="WaveNet，一种端到端的语音合成模型https-zhuanlan-zhihu-com-p-51359150"><a href="#WaveNet，一种端到端的语音合成模型https-zhuanlan-zhihu-com-p-51359150" class="headerlink" title="WaveNet，一种端到端的语音合成模型https://zhuanlan.zhihu.com/p/51359150"></a>WaveNet，一种端到端的语音合成模型<img src="/2020/11/03/WaveNet%E5%B0%8F%E7%BB%93/huangshengjie/Documents/2020/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99hexo%E6%B5%8B%E8%AF%95/Typora%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%E5%A4%B9/20201016164427.png" alt="image-20201016164426034"><a href="https://zhuanlan.zhihu.com/p/51359150" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/51359150</a></h3></li></ol><hr><h3 id="预测："><a href="#预测：" class="headerlink" title="预测："></a>预测：</h3><ol><li><p>机器学习各种 Loss 总结：</p><ol><li><a href="https://blog.csdn.net/perfect1t/article/details/88199179" target="_blank" rel="noopener">https://blog.csdn.net/perfect1t/article/details/88199179</a></li><li><a href="https://www.cnblogs.com/guoyaohua/p/9217206.html" target="_blank" rel="noopener">https://www.cnblogs.com/guoyaohua/p/9217206.html</a></li><li><a href="https://www.cnblogs.com/lliuye/p/9549881.html" target="_blank" rel="noopener">https://www.cnblogs.com/lliuye/p/9549881.html</a></li></ol></li><li><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201016181353.png" alt="image-20201016181352142"></p></li><li><p><img src="/2020/11/03/WaveNet%E5%B0%8F%E7%BB%93/huangshengjie/Documents/2020/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99hexo%E6%B5%8B%E8%AF%95/Typora%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%E5%A4%B9/image-20201019005049252.png" alt="image-20201019005049252"><a href="https://zhuanlan.zhihu.com/p/74874291" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/74874291</a></p></li><li><p>常见优化算法及其优缺点：</p><ol><li><p><a href="https://blog.csdn.net/qq_19446965/article/details/81591521" target="_blank" rel="noopener">https://blog.csdn.net/qq_19446965/article/details/81591521</a> </p></li><li><p><a href="http://www.julyedu.com/question/big/kp_id/23/ques_id/1524![image-20201016181800596](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201016181802.png)![image-20201016181557363](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201016181558.png)" target="_blank" rel="noopener">http://www.julyedu.com/question/big/kp_id/23/ques_id/1524![image-20201016181800596](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201016181802.png)![image-20201016181557363](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201016181558.png)</a></p></li><li><h3 id="深度学习中优化方法——momentum、Nesterov-Momentum、AdaGrad、Adadelta、RMSprop、Adam"><a href="#深度学习中优化方法——momentum、Nesterov-Momentum、AdaGrad、Adadelta、RMSprop、Adam" class="headerlink" title="深度学习中优化方法——momentum、Nesterov Momentum、AdaGrad、Adadelta、RMSprop、Adam"></a>深度学习中优化方法——momentum、Nesterov Momentum、AdaGrad、Adadelta、RMSprop、Adam</h3><ol><li><h3 id="https-blog-csdn-net-u012328159-article-details-80311892-image-20201019162755198-Users-huangshengjie-Documents-2020-个人网站hexo测试-Typora博客图片文件夹-20201019162757-png"><a href="#https-blog-csdn-net-u012328159-article-details-80311892-image-20201019162755198-Users-huangshengjie-Documents-2020-个人网站hexo测试-Typora博客图片文件夹-20201019162757-png" class="headerlink" title="https://blog.csdn.net/u012328159/article/details/80311892![image-20201019162755198](/Users/huangshengjie/Documents/2020/个人网站hexo测试/Typora博客图片文件夹/20201019162757.png)"></a><a href="https://blog.csdn.net/u012328159/article/details/80311892![image-20201019162755198](/Users/huangshengjie/Documents/2020/个人网站hexo测试/Typora博客图片文件夹/20201019162757.png)" target="_blank" rel="noopener">https://blog.csdn.net/u012328159/article/details/80311892![image-20201019162755198](/Users/huangshengjie/Documents/2020/个人网站hexo测试/Typora博客图片文件夹/20201019162757.png)</a></h3></li><li><p><a href="https://blog.csdn.net/u012328159/article/details/80252012![image-20201019162915626](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201019162916.png)" target="_blank" rel="noopener">https://blog.csdn.net/u012328159/article/details/80252012![image-20201019162915626](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201019162916.png)</a></p></li><li><p><a href="https://www.cnblogs.com/yangmang/p/7477802.html![image-20201019165031144](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201019165036.png)" target="_blank" rel="noopener">https://www.cnblogs.com/yangmang/p/7477802.html![image-20201019165031144](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201019165036.png)</a></p></li></ol></li></ol></li><li><p>常用激活函数：<a href="https://zhuanlan.zhihu.com/p/32610035![image-20201016224701337](/Users/huangshengjie/Documents/2020/个人网站hexo测试/Typora博客图片文件夹/20201016224703.png)" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32610035![image-20201016224701337](/Users/huangshengjie/Documents/2020/个人网站hexo测试/Typora博客图片文件夹/20201016224703.png)</a></p></li><li><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201016224719.jpg" alt="img"></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/73214810![image-20201016224906446](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201016224907.png)" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/73214810![image-20201016224906446](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201016224907.png)</a></p></li><li><p><a href="https://www.cnblogs.com/itmorn/p/11132494.html![image-20201019170355380](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201019170356.png)" target="_blank" rel="noopener">https://www.cnblogs.com/itmorn/p/11132494.html![image-20201019170355380](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201019170356.png)</a></p></li><li><p><a href="https://www.cnblogs.com/itmorn/tag/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95%E9%A2%98/default.html?page=2![image-20201019170708536](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201019170710.png)" target="_blank" rel="noopener">https://www.cnblogs.com/itmorn/tag/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95%E9%A2%98/default.html?page=2![image-20201019170708536](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201019170710.png)</a></p></li></ol><hr><ol><li><h6 id="A率13折线PCM编码的C语言实现-https-blog-csdn-net-u010480899-article-details-51172633-image-20201017001812322-Users-huangshengjie-Documents-2020-个人网站hexo测试-Typora博客图片文件夹-20201017001813-png"><a href="#A率13折线PCM编码的C语言实现-https-blog-csdn-net-u010480899-article-details-51172633-image-20201017001812322-Users-huangshengjie-Documents-2020-个人网站hexo测试-Typora博客图片文件夹-20201017001813-png" class="headerlink" title="A率13折线PCM编码的C语言实现 https://blog.csdn.net/u010480899/article/details/51172633![image-20201017001812322](/Users/huangshengjie/Documents/2020/个人网站hexo测试/Typora博客图片文件夹/20201017001813.png)"></a>A率13折线PCM编码的C语言实现 <a href="https://blog.csdn.net/u010480899/article/details/51172633![image-20201017001812322](/Users/huangshengjie/Documents/2020/个人网站hexo测试/Typora博客图片文件夹/20201017001813.png)" target="_blank" rel="noopener">https://blog.csdn.net/u010480899/article/details/51172633![image-20201017001812322](/Users/huangshengjie/Documents/2020/个人网站hexo测试/Typora博客图片文件夹/20201017001813.png)</a></h6></li><li><p><a href="https://blog.csdn.net/u012323667/article/details/79214336?utm_medium=distribute.pc_relevant_download.none-task-blog-blogcommendfrombaidu-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-blogcommendfrombaidu-1.nonecas![image-20201017003241394](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201017003242.png)" target="_blank" rel="noopener">https://blog.csdn.net/u012323667/article/details/79214336?utm_medium=distribute.pc_relevant_download.none-task-blog-blogcommendfrombaidu-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-blogcommendfrombaidu-1.nonecas![image-20201017003241394](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201017003242.png)</a></p></li><li><p>!                              <a href="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201017003854.png" target="_blank" rel="noopener">image-20201017003852920</a><a href="https://wenku.baidu.com/view/725f75bf1a37f111f1855b3c.html#![image-20201017003821332](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201017003822.png)" target="_blank" rel="noopener">https://wenku.baidu.com/view/725f75bf1a37f111f1855b3c.html#![image-20201017003821332](https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201017003822.png)</a></p></li></ol><p><strong>1</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;WaveNet小结&quot;&gt;&lt;a href=&quot;#WaveNet小结&quot; class=&quot;headerlink&quot; title=&quot;WaveNet小结&quot;&gt;&lt;/a&gt;WaveNet小结&lt;/h2&gt;
    
    </summary>
    
    
      <category term="语音" scheme="http://yoursite.com/categories/%E8%AF%AD%E9%9F%B3/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="语音合成" scheme="http://yoursite.com/tags/%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>《ONE-SHOT VOICE CONVERSION BY VECTOR QUANTIZATION》</title>
    <link href="http://yoursite.com/2020/10/18/10.18%E7%BB%84%E4%BC%9A-VQVC%20%E7%AE%80%E6%9E%90/"/>
    <id>http://yoursite.com/2020/10/18/10.18%E7%BB%84%E4%BC%9A-VQVC%20%E7%AE%80%E6%9E%90/</id>
    <published>2020-10-18T07:16:54.000Z</published>
    <updated>2020-11-01T03:45:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="1018组会"><a href="#1018组会" class="headerlink" title="1018组会"></a>1018组会</h3><h3 id="VQVC-简析"><a href="#VQVC-简析" class="headerlink" title="VQVC 简析"></a>VQVC 简析</h3><ul><li>《ONE-SHOT VOICE CONVERSION BY VECTOR QUANTIZATION》</li><li><a href="https://ericwudayi.github.io/VQVC-DEMO/" target="_blank" rel="noopener">https://ericwudayi.github.io/VQVC-DEMO/</a></li></ul><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201018132533.png" alt="image-20201018132532040"></p><ul><li>《VQVC+: One-Shot Voice Conversion by Vector Quantization and U-Net architecture》</li></ul><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201018001018.png" alt="image-20201018001016143"></p><a id="more"></a><hr><h2 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h2><ul><li>模型结构：AE 类型，U-Net 框架</li><li>常见 VC 特征解纠缠思路：The disentangle capability is achieved by vector quantization (VQ), adversarial training, or instance normalization (IN)<ul><li>VQ</li><li>对抗</li><li>IN</li></ul></li><li>VQVC：对 <strong>隐变量</strong> 进行 <strong>量化</strong></li></ul><hr><h2 id="2-相关"><a href="#2-相关" class="headerlink" title="2. 相关"></a>2. 相关</h2><h3 id="（一）直接转换语音，不需要单独-“特征解纠缠”"><a href="#（一）直接转换语音，不需要单独-“特征解纠缠”" class="headerlink" title="（一）直接转换语音，不需要单独 “特征解纠缠”"></a>（一）直接转换语音，不需要单独 “特征解纠缠”</h3><ol><li>CycleGAN &amp;&amp; StarGAN 专注于解决 <strong>“多对多问题”</strong> </li><li>BLOW：基于Flow的方式：<strong>直接对 波形 进行转换，而不用转换成 语音特征</strong></li></ol><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="（二）-speaker-amp-amp-linguistic-解耦"><a href="#（二）-speaker-amp-amp-linguistic-解耦" class="headerlink" title="（二） speaker &amp;&amp; linguistic 解耦"></a>（二） speaker &amp;&amp; linguistic 解耦</h3><ol><li>AutoVC—— AE 结构，通过控制 <strong>隐变量</strong> 尺寸（layer dimension）来实现解纠缠</li><li>IN 法<img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201101114502.png" alt="image-20201018105402931"></li><li>VQVC</li></ol><hr><h2 id="3-加入-U-Net-的原因："><a href="#3-加入-U-Net-的原因：" class="headerlink" title="3. 加入 U-Net 的原因："></a>3. 加入 U-Net 的原因：</h2><ul><li>以上这些 特征解纠缠 的思路可行，但是由于这些额外限制，会使得重构音质受损</li><li>U-Net 的重构能力超级强，所以本身是没法做 VC 的，因为她 解纠缠 能力不好</li><li>本文尝试 结合 U-Net 的强大重构能力，以及 VQ 的 特征解耦能力，使得转换的语音，在相似度提高的同时，解决流畅度问题；</li></ul><hr><h2 id="4-VQVC-思路："><a href="#4-VQVC-思路：" class="headerlink" title="4. VQVC 思路："></a>4. VQVC 思路：</h2><ul><li>内容：离散码</li><li>说话人信息：连续语音信号 - 离散码</li></ul><ol><li>先做 Encode 得到隐变量 Z；</li><li>再对这个隐变量做 量化，（结合 codebook ），提取出 内容向量 C（content embedding）——不同说话人，说同样一句话，得到的向量趋于相似向量值；</li><li>将 Z 和 C 做量化减法，得到 Speaker Embedding——S</li></ol><p>内容：离散码<br>说话人信息：连续语音信号-离散码</p><ol start="4"><li></li></ol><hr><ul><li>Codebook 本身是可训练的</li><li><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201018152001.png" alt="image-20201018152000315"></li><li><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201018152107.png" alt="image-20201018152105943"></li></ul><p>公式（1）：</p><ul><li><p>x（带帽）表示的是 语音 x 中的一个小片段；</p></li><li><p><strong>argmin</strong> 函数：求取 使得函数 y = f(x) 取得最小值的 x 值集合</p></li><li><p>将 Encode 之后的 隐变量 z，拿来和 Codebook 中的向量 求取差值最小项（欧式距离）</p></li><li><p>最后的 $C_x$ 是将上述 x^ 做一个整体的 concate 得到的</p></li></ul><p>公式（2）：</p><p>结合（VQVC+）的部分公式 来看：<img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201018152951.png" alt="image-20201018152950185"></p><ul><li>$E_t$ 表示的是，在所有 T 帧上，求取 Z 和 C 的<strong>期望值 s</strong>，最后将 s 重复 T 次，以此表征 speaker embedding；</li><li>重复 T 次是为了让 s 的尺寸 和 C 一样，并方便后续操作</li></ul><p>公式（3）：</p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201018153359.png" alt="image-20201018153358420"></p><ul><li>第一个损失： <strong>重构损失</strong> </li></ul><p>公式（4）、（5）：</p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201018153716.png" alt="image-20201018153714828"></p><ul><li>第二个损失：隐变量损失 L(latent)</li><li>目的是更好地从 隐变量Z 中提取 Content Embedding，来代表整个语音片段的内容部分</li><li>🌟值得一提的是：为了让 C 更好地表征内容，在这个环节中，Codebook不做更新：防止网络为了缩小 Loss，而把 Codebook 往 说话人信息方向靠，使得提取出来的 Content Embedding 含有 Spealer 信息；</li></ul><p>公式（5）：</p><ul><li>两个 Loss 的叠加</li></ul><hr><h2 id="关于-IN："><a href="#关于-IN：" class="headerlink" title="关于 IN："></a>关于 IN：</h2><ul><li>本图来自（VQVC+）：</li></ul><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201018154453.png" alt="image-20201018154451621"></p><ul><li>在 Encode 得到隐变量 z 之后，在进一步提取 content embedding 之前，需要先做一次 IN（Instant Norm）</li><li>IN 本身也被其他论文证明，具有</li><li>特征解耦 的功效（这里 IN 是必须操作）</li><li>这样能预先一步过滤 说话人信息</li></ul><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201018160224.png" alt="image-20201018160153595"></p><hr><h2 id="一些特征处理细节："><a href="#一些特征处理细节：" class="headerlink" title="一些特征处理细节："></a>一些特征处理细节：</h2><ul><li>n_mels = 160</li><li>GriffinLim</li><li>24K</li><li>一些额外的规范化normalize 处理：<ul><li>减去均值，除以均方差，处理到【0，1】</li></ul></li></ul><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201018155430.png" alt="image-20201018155429424"></p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201018155439.png" alt="image-20201018155438508"></p><hr><h2 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h2><ol><li>消融实验</li></ol><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201018162111.png" alt="image-20201018162109398"></p><ol start="2"><li>ABX 实验<img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201018162140.png" alt="image-20201018162138602"></li></ol><ol start="3"><li><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201018162224.png" alt="image-20201018162222357"></p></li><li><p>Speaker Embedding 区分度：语音片段长度120帧；CodeBook 尺寸 32；训练使用数据 20 人<img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201018162242.png" alt="image-20201018162241525"></p></li></ol><h2 id="疑问点："><a href="#疑问点：" class="headerlink" title="疑问点："></a>疑问点：</h2><ul><li><p>量化部分的具体操作看不懂，说的不详细</p></li><li><p>没有代码对照</p></li></ul><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201018155903.png" alt="image-20201018155901510"></p><hr><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>创新意义 &gt; 实用意义</li><li>没脱离 AE 结构，还是在隐变量 特征解耦上做文章，效果不突出；</li><li>Demo 听起来，语气语调信息损失严重</li><li>当作已有方法总结中的一种，不建议使用</li></ul><hr><ul><li>开题报告</li><li>PPT</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1018组会&quot;&gt;&lt;a href=&quot;#1018组会&quot; class=&quot;headerlink&quot; title=&quot;1018组会&quot;&gt;&lt;/a&gt;1018组会&lt;/h3&gt;&lt;h3 id=&quot;VQVC-简析&quot;&gt;&lt;a href=&quot;#VQVC-简析&quot; class=&quot;headerlink&quot; title=&quot;VQVC 简析&quot;&gt;&lt;/a&gt;VQVC 简析&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;《ONE-SHOT VOICE CONVERSION BY VECTOR QUANTIZATION》&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ericwudayi.github.io/VQVC-DEMO/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ericwudayi.github.io/VQVC-DEMO/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201018132533.png&quot; alt=&quot;image-20201018132532040&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《VQVC+: One-Shot Voice Conversion by Vector Quantization and U-Net architecture》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20201018001018.png&quot; alt=&quot;image-20201018001016143&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="论文阅读笔记" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="VC" scheme="http://yoursite.com/tags/VC/"/>
    
      <category term="论文阅读笔记" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《EMOTIONAL VOICE CONVERSION USING MULTITASK LEARNING WITH TEXT-TO-SPEECH》</title>
    <link href="http://yoursite.com/2020/09/20/0920-EMOTIONAL%20VOICE%20CONVERSION%20USING%20MULTITASK%20LEARNING%20WITH%20TEXT-TO-SPEECH/"/>
    <id>http://yoursite.com/2020/09/20/0920-EMOTIONAL%20VOICE%20CONVERSION%20USING%20MULTITASK%20LEARNING%20WITH%20TEXT-TO-SPEECH/</id>
    <published>2020-09-20T12:20:58.000Z</published>
    <updated>2020-09-20T16:37:29.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>0920-论文总结</p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200921003657.png" alt="image-20200916195211586"></p><p>2020.09.20</p><a id="more"></a><h2 id="本周完成的工作："><a href="#本周完成的工作：" class="headerlink" title="本周完成的工作："></a>本周完成的工作：</h2><p>（写了比较多的<strong>验证实验代码</strong>，助于理解原理）</p><ol><li><p>学习掌握了 <strong>LMDB</strong> 格式数据的处理（创建/插入/读取/修改）</p></li><li><p>实现了 <strong>Numpy 类型数据转 lmdb</strong>（<strong>librosa</strong>提取出来的<strong>mel</strong>数据需要处理成 <strong>连续存储</strong> <strong>np.ascontiguousarray（）</strong>）</p></li><li><p>从 lmdb 读取数据，并转换成 numpy（<strong>np.fromstring(value, dtype=np.float32)</strong>），并完整复原成语音。</p></li><li><p><strong>Mel —&gt;(griffin)—&gt;wav</strong>：对比试验了几个版本的 tacotron 的语音数据处理代码， 结合网上资料，总结一套转换效果质量较好的 代码：（mag -&gt; mel ; <strong>mel -&gt; mag</strong>; mag -&gt;wave）【很多资料版本在借用<strong>griffin</strong>实现 <strong>mel 转 幅度谱 mag</strong> 环节，写的不够好甚至没写清楚】</p><hr></li><li><p>数据处理环节：NVAE 中的 图像处理是【n，n】，所以采用 【<strong>256帧，n_mels=256</strong>】的参数来提取 <strong>mel</strong>（<strong>80 维的griffin复原效果太差</strong></p><hr></li><li><p>🌟<strong>NVAE图像**</strong>训爆了<strong>：和作者联系，问题定位在 batch太小（原32，咱们用 4【GPU限制】）情况下，</strong>learning_rate太大：1e-2 改 1e-3</p></li><li><p>在epoch <strong>5</strong> 掉链子：<strong>warm_up</strong>环节刚过，学习率有变，所以导致数据算成了 <strong>NAN</strong>；模型保存也只保存到 <strong>epoch 1</strong>，<strong>改部分代码，先 一个epoch一个epoch保存 ckpt</strong></p></li></ol><hr><h2 id="可改进："><a href="#可改进：" class="headerlink" title="可改进："></a>可改进：</h2><ol><li>晚上先试着跑起来</li><li>后面尝试改进 NVAE 代码成 <strong>自适应 数据尺寸【m，n】（m != n）</strong></li><li>在tensorboard上看下怎么展示中间步骤语音 .wav</li></ol><hr><hr><h2 id="论文涉猎"><a href="#论文涉猎" class="headerlink" title="论文涉猎"></a>论文涉猎</h2><h2 id="情感语音转换（TTS-VC-多任务学习）"><a href="#情感语音转换（TTS-VC-多任务学习）" class="headerlink" title="情感语音转换（TTS + VC 多任务学习）"></a><strong>情感语音转换</strong>（TTS + VC 多任务学习）</h2><ul><li><h3 id="VC领域-痛点：保存语言信息，情感信息-和-多对多VC方面，VC的性能仍然很差"><a href="#VC领域-痛点：保存语言信息，情感信息-和-多对多VC方面，VC的性能仍然很差" class="headerlink" title="VC领域 痛点：保存语言信息，情感信息 和 多对多VC方面，VC的性能仍然很差"></a>VC领域 <strong>痛点</strong>：<strong>保存语言信息</strong>，<strong>情感信息</strong> 和 <strong>多对多VC</strong>方面，VC的性能仍然很差</h3></li><li><h3 id="解决的问题：在-2017-年一篇-“情感VC转换”-基础上，提升“转换后内容保留程度”（即，降低WER）（retaining-linguistic-contents）"><a href="#解决的问题：在-2017-年一篇-“情感VC转换”-基础上，提升“转换后内容保留程度”（即，降低WER）（retaining-linguistic-contents）" class="headerlink" title="解决的问题：在 2017 年一篇 “情感VC转换” 基础上，提升“转换后内容保留程度”（即，降低WER）（retaining linguistic contents）"></a><strong>解决的问题</strong>：在 2017 年一篇 “情感VC转换” 基础上，<strong>提升“转换后内容保留程度”</strong>（即，降低WER）（retaining linguistic contents）</h3></li></ul><hr><ul><li>有<strong>提供源码</strong>，缺 demo 展示（文件夹下载需代理，网速极其慢， 300+m 大小 /  3kb/s）</li></ul><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200916195217.png" alt="image-20200916195211586"></p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200919174026.png" alt="image-20200919174025442"></p><hr><ul><li>最新的 VC 思路是 序列到序列（Sequence 2 Seq），但是容易丢失语音信息<ul><li>可以通过文本监督来矫正：<ul><li>但是对齐是个问题；</li><li>另外这样也失去了 S2S 的优势了</li></ul></li></ul></li><li>本文思路：<ul><li>利用 <strong>多任务学习的 TTS 模型</strong>，来帮助 VC 模型 <strong>捕获语言信息</strong>并<strong>保持训练稳定性</strong>。</li><li>TTS 框架来源 tacotron（有局部的稍微改动）：（Style Encoder 也是借鉴这篇）<img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200921003719.png" alt="image-20200919190909558"></li><li>VC 框架：另外并联一个 “Content Encoder”</li></ul></li></ul><hr><h2 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h2><ul><li><strong>并不像</strong>传统做 <strong>情感转换</strong>那样，在训练阶段就提取 情感标签（one-hot形式）；</li><li>在整个网络中，也不会将 <strong>情感标签</strong> 当作一个条件作为输入 （<strong>联想一下之前的 pitch 标签</strong>）</li><li></li><li>可以在<strong>单个模型中</strong>执行<strong>VC</strong>和<strong>TTS</strong></li></ul><hr><h2 id="网络结构："><a href="#网络结构：" class="headerlink" title="网络结构："></a>网络结构：</h2><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200919173504.png" alt="image-20200919173502738"></p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200919185336.png" alt="image-20200919185334992"></p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200919204207.png" alt="image-20200919204205843"></p><hr><h2 id="TTS-支线：（以-tacotron-为原型）"><a href="#TTS-支线：（以-tacotron-为原型）" class="headerlink" title="TTS 支线：（以 tacotron 为原型）"></a>TTS 支线：（以 tacotron 为原型）</h2><ol><li><strong>模仿的是</strong>：</li></ol><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200919190911.png" alt="image-20200919190909558"></p><ol start="2"><li><strong>框架</strong>：</li></ol><ul><li>text encoder, </li><li>decoder,</li><li>attention, </li><li>and post processor</li></ul><ol start="3"><li><strong>改动：(参考 [17] 文献)</strong><ol><li>文字向量<strong>context vector $C_t$</strong> 被用在 <strong>AttentionRNN</strong> 的每个循环内（context vector c (t)utilizes is used for every iteration in attention RNN）[原本是怎么样的？查一下]</li><li>在 <strong>CBHG</strong> (Convolution Bank + Highway + bi-GRU) 模块中，增加了 *<em>残余连接 (residual connection) *</em>模块</li></ol></li></ol><hr><hr><h2 id="Loss"><a href="#Loss" class="headerlink" title="Loss"></a>Loss</h2><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200919194706.png" alt="image-20200919194704841"></p><ul><li>Loss 就是直接比较： <strong>mel谱</strong> 差距 &amp;&amp; <strong>线性谱</strong> 差距</li></ul><hr><h2 id="实验参数："><a href="#实验参数：" class="headerlink" title="实验参数："></a>实验参数：</h2><ol><li>大体上都是和 taco 部分的语音预处理手法相似</li><li>数据集：<ol><li>韩国某个30岁男子，用七种情绪，每种情绪说 3k 句；共 2.1w 句；</li><li>其中情感：（neutral, happiness, sadness, anger, fear, surprise, and disgust)</li><li>去除静音之后，共约 29.2 h</li></ol></li><li>🌟值得一提的几点：<ol><li>去除静音，不是像taco那样，用 <strong>librosa.effect.trim()</strong> ，而是用voice activity detection algorithm （VAD 算法：开源）</li><li>在做 TTS-taco-like 部分里，<strong>字符处理</strong>有特点：【在转换为 <strong>one-hot embedding</strong> 这种表示形式之前会分解为 <strong>开始</strong>，<strong>核心</strong> 和 <strong>尾声</strong>（<strong>onset, nucleus, and coda</strong>）】</li><li>256 character embedding, 32 dimensions for $h_c$</li></ol></li></ol><hr><h2 id="🌟重要的一个验证实验"><a href="#🌟重要的一个验证实验" class="headerlink" title="🌟重要的一个验证实验"></a>🌟重要的一个验证实验</h2><p>——（<strong>内容一致性</strong>验证 <strong>Linguistic consistency</strong>）</p><ol><li>每种情感 取20条句子</li><li>用 StyleEncoder 提取 “<strong>style vector</strong>”，并用<strong>余弦相似度</strong>来查看<strong>情感分离程度</strong>（验证情感特征提取的有效性）</li></ol><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200920161149.png" alt="image-20200920161147834"></p><ol><li>每种情感 句子 的<strong>内容 $X_s$</strong> 保持不变，选取七种句子（同内容），做“从中性情感”到“其他六种情感”的转换</li><li>结果上看，<strong>log mel</strong> 语谱图 <strong>尺寸形状大差不差</strong></li><li>有些许差异的地方：<ol><li>时间偏移，</li><li>频率偏移，</li><li>暂停持续时间</li></ol></li><li>总体上能实现，<strong>由一种情感，随意 VC 转换到其他情感</strong> 的能力</li></ol><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200920161207.png" alt="image-20200920161206290"></p><hr><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200920145005.png" alt="image-20200920145003900"></p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200919205459.png" alt="image-20200919205457583"></p><ol><li>在联合训练的帮助下：<ol><li>VCTTS-VC 在内容保留能力上的效果，比单纯的 VC ，正确率要提高不少</li><li>另一方面，VCTTS-TTS 比单纯的 TTS 没有太大进步，甚至有一点点下降</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;0920-论文总结&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200921003657.png&quot; alt=&quot;image-20200916195211586&quot;&gt;&lt;/p&gt;
&lt;p&gt;2020.09.20&lt;/p&gt;
    
    </summary>
    
    
      <category term="论文阅读笔记" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
      <category term="test" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/test/"/>
    
    
      <category term="VC" scheme="http://yoursite.com/tags/VC/"/>
    
      <category term="论文阅读笔记" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《PITCHNET —— UNSUPERVISED SINGING VOICE CONVERSION WITH PITCH ADVERSARIAL NETWORK》</title>
    <link href="http://yoursite.com/2020/09/07/0906%E7%BB%84%E4%BC%9A%E5%88%86%E4%BA%AB%EF%BC%9A%E6%AD%8C%E5%94%B1%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/09/07/0906%E7%BB%84%E4%BC%9A%E5%88%86%E4%BA%AB%EF%BC%9A%E6%AD%8C%E5%94%B1%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-09-07T07:16:54.000Z</published>
    <updated>2020-09-20T16:35:13.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>0906组会分享</p><h2 id="0906组会分享：歌唱转换-singing-voice-conversion"><a href="#0906组会分享：歌唱转换-singing-voice-conversion" class="headerlink" title="0906组会分享：歌唱转换 singing voice conversion"></a>0906组会分享：<strong>歌唱转换 singing voice conversion</strong></h2><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200905170752.png" alt="image-20200905170750870"></p><ul><li><p>效果概览：<a href="https://tencent-ailab.github.io/pitch-net/" target="_blank" rel="noopener">https://tencent-ailab.github.io/pitch-net/</a></p></li><li><p>MOS评分：</p><ul><li>Baseline ：2.92</li><li>PitchNet：3.75</li></ul></li></ul><a id="more"></a><ul><li><h2 id="论文的-baseline-对象："><a href="#论文的-baseline-对象：" class="headerlink" title="论文的 baseline 对象："></a>论文的 <strong>baseline</strong> 对象：<img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200905171530.png" alt="image-20200905171528462"></h2></li><li><h2 id="BaseLine-的贡献和缺点"><a href="#BaseLine-的贡献和缺点" class="headerlink" title="BaseLine 的贡献和缺点"></a><strong>BaseLine 的贡献和缺点</strong></h2></li></ul><p>贡献：</p><ol><li>利用 AE 模式下的无监督方式，解决了 平行语料的问题</li><li>组成模块：<strong>WaveNetlike Encoder</strong> &amp;&amp;  <strong>WaveNet  autoregressive Decoder</strong> &amp;&amp; <strong>Speaker-Embedding Table</strong>（leanable）</li></ol><p>缺点：</p><ol><li>和StarGan-VC之类的 单纯说话VC 任务不同，歌唱转换的效果重点是：说话人相似性 &amp;&amp; 音调合理性</li><li>BaseLine 在音调处理上差强人意，总而言之，“<strong>语音和音调的联合表示</strong>”是难点</li></ol><hr><ul><li><h2 id="解决的问题："><a href="#解决的问题：" class="headerlink" title="解决的问题："></a><strong>解决的问题</strong>：</h2></li></ul><ol><li>走调（音高 Pitch 失控现象）问题的缓解<ol><li>在 Baseline 的 <strong>AE无监督</strong> 模式下，附带一个额外的<strong>音调回归网络（GAN）</strong>可以将音调信息从潜在空间中分离出来</li><li><strong>目的是</strong>：让原本的<strong>Encoder</strong>在单纯学习 <strong>说话人无关的语言信息</strong> 基础上，再额外剥离掉 <strong>音高信息</strong> （<strong>not only singer-invariant but also pitch-invariant representation</strong>）</li></ol></li><li>至于音高信息，当成一个独立问题来解决：设立独立模块来提取 <strong>source</strong> 的<strong>音高信息</strong>，以此配合 <strong>Decoder</strong> ，来<strong>操控</strong> <strong>生成语音</strong> 的<strong>音高</strong> <ol><li>（根据作者相关 Git 项目下的 issue 讨论，这部分工作借用 Kaldi 来完成）</li><li>【实现 <strong>音高可控性</strong> 】</li></ol></li></ol><hr><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a><strong>模型</strong></h2><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200905223846.png" alt="image-20200905223845590"></p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200905223859.png" alt="image-20200905223857883"></p><ul><li><strong>Singer Classiﬁcation Network</strong> <strong>Pitch Regression Network</strong> 是为了使得 <strong>Encoder</strong> 能够在抽取特征向量 <strong>z</strong> 时，把 说话人信息 &amp;&amp; 音调信息 都剥离掉</li><li></li><li></li></ul><hr><h2 id="Training-Loss：三个Loss"><a href="#Training-Loss：三个Loss" class="headerlink" title="Training Loss：三个Loss"></a><strong>Training Loss：三个Loss</strong></h2><ol><li><strong>singer classiﬁcation loss</strong></li><li><strong>pitch regression loss</strong></li><li><strong>reconstruction loss</strong></li></ol><h2 id="几个公式的清晰理解："><a href="#几个公式的清晰理解：" class="headerlink" title="几个公式的清晰理解："></a>几个公式的清晰理解：</h2><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200906141104.png" alt="image-20200906141103220"></p><ol><li>说明了AE网络的Decoder产生结果 所需要的输入元素（Encoder结果+Kaldi抽取的音高+Embedding信息）</li><li>介绍重构损失：在Decoder时配合<strong>source</strong>的embedding，和<strong>source</strong>语音做<strong>Loss</strong></li></ol><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200906141139.png" alt="image-20200906141138234"></p><ol start="3"><li>一个 <strong>说话人分类器</strong>，同理为 StarGan-VC 的Domain-Classification，分类对象，是<strong>Encoder</strong>结果&amp;&amp;<strong>Embedding</strong></li><li>另一个<strong>音高分类器</strong>，Pitch信息由 Kaldi 提取</li><li>总的<strong>Loss</strong>结构：因为重构损失⬇️越好，另一方面，对于两个分类器，我们希望我们的 <strong>Encoder</strong>提取出来的隐变量 能彻底剥离 说话人信息 &amp;&amp; Pitch信息，所以这两个的误差，对于结果来说，应该越大越好。（所以这两个部分是配合 负号）</li><li>上述两个 C分类器的损失，对于<strong>Encoder</strong>和<strong>Classifier</strong>来说，是完全相反的，【<strong>就是典型的GAN对抗思路</strong>】，所以他们的训练，采取“你一次我一次的过程”<ul><li>训练中，缩小 $$L_{total}$$ 时，促进的是 <strong>Encoder</strong> 将两个元素剥离</li><li>缩小 $L_{ad}$ 时，促进的是 <strong>Classifier</strong> 具有更强的分类能力，能看透隐变量 <strong>z</strong> 的实质和归属</li></ul></li></ol><p>Ps.整体思路比较清晰，就是<strong>自回归</strong>那个部分不知道是怎么具体实现的</p><hr><p>Quantitative and Qualitative Experiments**【定量 和 定性 实验】</p><hr><p>Tencent :LPCNet, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python convert_tfrecord_to_lmdb.py --dataset&#x3D;celeba --tfr_path&#x3D;&#x2F;data&#x2F;hsj&#x2F;NVAE&#x2F;DATA_DIR&#x2F;celeba&#x2F;celeba-tfr --lmdb_path&#x3D;&#x2F;data&#x2F;hsj&#x2F;NVAE&#x2F;DATA_DIR&#x2F;celeba&#x2F;celeba-lmdb --split&#x3D;train</span><br><span class="line">python convert_tfrecord_to_lmdb.py --dataset&#x3D;celeba --tfr_path&#x3D;&#x2F;data&#x2F;hsj&#x2F;NVAE&#x2F;DATA_DIR&#x2F;celeba&#x2F;celeba-tfr --lmdb_path&#x3D;&#x2F;data&#x2F;hsj&#x2F;NVAE&#x2F;DATA_DIR&#x2F;celeba&#x2F;celeba-lmdb --split&#x3D;validation</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export EXPR_ID&#x3D;&#x2F;data&#x2F;hsj&#x2F;NVAE&#x2F;EXPR_ID</span><br><span class="line">export DATA_DIR&#x3D;&#x2F;data&#x2F;hsj&#x2F;NVAE&#x2F;DATA_DIR&#x2F;celeba&#x2F;celeba-lmdb</span><br><span class="line">export CHECKPOINT_DIR&#x3D;&#x2F;data&#x2F;hsj&#x2F;NVAE&#x2F;CHECKPOINT_DIR</span><br><span class="line">export CODE_DIR&#x3D;&#x2F;data&#x2F;hsj&#x2F;NVAE</span><br><span class="line">cd &#x2F;data&#x2F;hsj&#x2F;NVAE</span><br><span class="line">CUDA_VISIBLE_DEVICES&#x3D;1  </span><br><span class="line">python train.py --data &#x2F;data&#x2F;hsj&#x2F;NVAE&#x2F;DATA_DIR&#x2F;celeba&#x2F;celeba-lmdb --root &#x2F;data&#x2F;hsj&#x2F;NVAE&#x2F;CHECKPOINT_DIR --save &#x2F;data&#x2F;hsj&#x2F;NVAE&#x2F;EXPR_ID --dataset celeba_64 \</span><br><span class="line">        --num_channels_enc 64 --num_channels_dec 64 --epochs 90 --num_postprocess_cells 2 --num_preprocess_cells 2 \</span><br><span class="line">        --num_latent_scales 3 --num_latent_per_group 20 --num_cell_per_cond_enc 2 --num_cell_per_cond_dec 2 \</span><br><span class="line">        --num_preprocess_blocks 1 --num_postprocess_blocks 1 --weight_decay_norm 1e-1 --num_groups_per_scale 20 \</span><br><span class="line">        --batch_size 16 --num_nf 1 --ada_groups --num_process_per_node 8 --use_se --res_dist --fast_adamax</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CelebA64 数据预处理</span><br><span class="line"></span><br><span class="line">cd $CODE_DIR&#x2F;scripts</span><br><span class="line">python create_celeba64_lmdb.py --split train --img_path .&#x2F;DATA_DIR&#x2F;celeba_org&#x2F;celeba --lmdb_path  .&#x2F;DATA_DIR&#x2F;celeba64_lmdb</span><br><span class="line">python create_celeba64_lmdb.py --split valid --img_path .&#x2F;DATA_DIR&#x2F;celeba_org&#x2F;celeba --lmdb_path  .&#x2F;DATA_DIR&#x2F;celeba64_lmdb</span><br><span class="line">python create_celeba64_lmdb.py --split test  --img_path .&#x2F;DATA_DIR&#x2F;celeba_org&#x2F;celeba --lmdb_path  .&#x2F;DATA_DIR&#x2F;celeba64_lmdb</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python create_celeba64_lmdb.py --split train --img_path ..&#x2F;DATA_DIR&#x2F;celeba_org&#x2F;celeba --lmdb_path ..&#x2F;DATA_DIR&#x2F;celeba64_lmdb</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python convert_tfrecord_to_lmdb.py --dataset&#x3D;celeba --split&#x3D;validation</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python train.py --data $DATA_DIR&#x2F;celeba64_lmdb --root $CHECKPOINT_DIR --save $EXPR_ID --dataset celeba_64 \</span><br><span class="line">        --num_channels_enc 64 --num_channels_dec 64 --epochs 90 --num_postprocess_cells 2 --num_preprocess_cells 2 \</span><br><span class="line">        --num_latent_scales 3 --num_latent_per_group 20 --num_cell_per_cond_enc 2 --num_cell_per_cond_dec 2 \</span><br><span class="line">        --num_preprocess_blocks 1 --num_postprocess_blocks 1 --weight_decay_norm 1e-1 --num_groups_per_scale 20 \</span><br><span class="line">        --batch_size 16 --num_nf 1 --ada_groups --num_process_per_node 8 --use_se --res_dist --fast_adamax</span><br></pre></td></tr></table></figure><p>/Users/huangshengjie/Desktop/NVAE/scripts/data1/datasets/imagenet-oord</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;0906组会分享&lt;/p&gt;
&lt;h2 id=&quot;0906组会分享：歌唱转换-singing-voice-conversion&quot;&gt;&lt;a href=&quot;#0906组会分享：歌唱转换-singing-voice-conversion&quot; class=&quot;headerlink&quot; title=&quot;0906组会分享：歌唱转换 singing voice conversion&quot;&gt;&lt;/a&gt;0906组会分享：&lt;strong&gt;歌唱转换 singing voice conversion&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200905170752.png&quot; alt=&quot;image-20200905170750870&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;效果概览：&lt;a href=&quot;https://tencent-ailab.github.io/pitch-net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://tencent-ailab.github.io/pitch-net/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MOS评分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Baseline ：2.92&lt;/li&gt;
&lt;li&gt;PitchNet：3.75&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文阅读笔记" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="VC" scheme="http://yoursite.com/tags/VC/"/>
    
      <category term="论文阅读笔记" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>0830组会分享——几种卷积辨析 &amp;&amp; SELayer论文及代码实现</title>
    <link href="http://yoursite.com/2020/08/31/0830%E7%BB%84%E4%BC%9A%E5%88%86%E4%BA%AB/"/>
    <id>http://yoursite.com/2020/08/31/0830%E7%BB%84%E4%BC%9A%E5%88%86%E4%BA%AB/</id>
    <published>2020-08-31T11:20:58.000Z</published>
    <updated>2020-09-20T16:40:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="几种卷积类型辨析"><a href="#几种卷积类型辨析" class="headerlink" title="几种卷积类型辨析"></a>几种卷积类型辨析</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conv = nn.Conv2d(in_channels=<span class="number">6</span>, out_channels=<span class="number">6</span>, kernel_size=<span class="number">1</span>, groups=<span class="number">3</span>)</span><br><span class="line">conv.weight.data.size()</span><br><span class="line"></span><br><span class="line"><span class="comment"># output = torch.Size([6, 2, 1, 1])</span></span><br></pre></td></tr></table></figure><p>一种分类方法：</p><p>几种卷积示意：（分组卷积 <strong>group_convolution</strong>；深度卷积 <strong>depthwise convolution</strong>； 全局深度卷积 <strong>global depthwise convolution</strong>）</p><ol><li>groups 默认值为1， 对应的是<strong>常规卷积</strong>操作</li><li>groups &gt; 1， 且能够同时被in_channel / out_channel整除，对应<strong>group_convolution</strong></li><li>groups == input_channel == out_channel , 对应<strong>depthwise convolution</strong>,为条件2的特殊情况</li><li>在条件3的基础上，各卷积核的 H == input_height; W == input_width, 对应为 <strong>global depthwise convolution</strong>, 为条件3的特殊情况</li><li></li></ol><hr><p>另一种分类方法：<strong>主要分三类：正常卷积、分组卷积、深度分离卷积</strong></p><a id="more"></a><!--more--><ol><li><h2 id="正常卷积："><a href="#正常卷积：" class="headerlink" title="正常卷积："></a><strong>正常卷积：</strong></h2></li><li><p>参数量 = cin *  $K_h$ * $K_w$ * cout</p></li><li><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200830111253.png" alt="常规卷积示意图"></p></li><li><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200830103246.jpeg" alt="img"></p></li><li><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200830103436.png" alt="img"></p></li><li></li><li><h2 id="分组卷积示意图："><a href="#分组卷积示意图：" class="headerlink" title="分组卷积示意图："></a><strong>分组卷积示意图：</strong></h2></li><li><p>参数量： (cin * $K_h$ * $K_w$* cout ) / Groups</p></li><li><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200830111236.png" alt="分组卷积示意图"></p></li><li><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200830103353.jpeg" alt="img"></p></li><li><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200830103314.png" alt="img"></p></li><li><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">GroupConv</span><span class="params">(nn.Module)</span>:</span>  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, in_ch, out_ch, groups)</span>:</span>      super(GroupConv, self).__init__()      self.conv = nn.Conv2d(          in_channels=in_ch,          out_channels=out_ch,          kernel_size=<span class="number">3</span>,          stride=<span class="number">1</span>,          padding=<span class="number">1</span>,          groups=groups      )  <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input)</span>:</span>      out = self.conv(input)      <span class="keyword">return</span> out</code></pre></li></ol><pre><code># 测试conv = CSDN_Tem(16, 32, 4)print(summary(conv, (16, 64, 64), batch_size=1))********************************----------------------------------------------------------------        Layer (type)               Output Shape         Param #================================================================            Conv2d-1            [1, 32, 64, 64]           1,184================================================================Total params: 1,184Trainable params: 1,184Non-trainable params: 0----------------------------------------------------------------Input size (MB): 0.25Forward/backward pass size (MB): 1.00Params size (MB): 0.00Estimated Total Size (MB): 1.25----------------------------------------------------------------<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">13. </span><br><span class="line"></span><br><span class="line">14. </span><br><span class="line"></span><br><span class="line">15. ## [深度可分离卷积(Depthwise Separable Convolution)][https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_30793735&#x2F;article&#x2F;details&#x2F;88915612]</span><br><span class="line"></span><br><span class="line">16. 参数量： $C_&#123;in&#125;$ * $K_h$ * $K_w$ + $C_&#123;out&#125;$ * 1 * 1</span><br><span class="line"></span><br><span class="line">17. 理解上，可以看作是， 先做一次 cin &#x3D;&#x3D; cout 的 分组卷积， 并且 groups &#x3D;&#x3D; channels，即每个通道作为一组； 然后再对上述结果，做一次 **逐点卷积(Pointwise Convolution)** 实现通道数改变的，这个过程使用大小为 **Cin * 1 * 1 ** 的卷积核实现，数量为 **Cout** 个</span><br><span class="line"></span><br><span class="line">18. &#96;&#96;&#96;python</span><br><span class="line">    class DepthSepConv(nn.Module):</span><br><span class="line">        def __init__(self, in_ch, out_ch):</span><br><span class="line">            super(DepthSepConv, self).__init__()</span><br><span class="line">            self.depth_conv &#x3D; nn.Conv2d(</span><br><span class="line">                in_channels&#x3D;in_ch,</span><br><span class="line">                out_channels&#x3D;in_ch,</span><br><span class="line">                kernel_size&#x3D;3,</span><br><span class="line">                stride&#x3D;1,</span><br><span class="line">                padding&#x3D;1,</span><br><span class="line">                groups&#x3D;in_ch</span><br><span class="line">            )</span><br><span class="line">            self.point_conv &#x3D; nn.Conv2d(</span><br><span class="line">                in_channels&#x3D;in_ch,</span><br><span class="line">                out_channels&#x3D;out_ch,</span><br><span class="line">                kernel_size&#x3D;1,</span><br><span class="line">                stride&#x3D;1,</span><br><span class="line">                padding&#x3D;0,</span><br><span class="line">                groups&#x3D;1</span><br><span class="line">            )</span><br><span class="line">    </span><br><span class="line">        def forward(self, input):</span><br><span class="line">            out &#x3D; self.depth_conv(input)</span><br><span class="line">            out &#x3D; self.point_conv(out)</span><br><span class="line">            return out</span><br><span class="line">    </span><br><span class="line">          </span><br><span class="line">    # 测试</span><br><span class="line">    conv &#x3D; DepthSepConv(16, 32)</span><br><span class="line">    print(summary(conv, (16, 64, 64), batch_size&#x3D;1))</span><br><span class="line">    </span><br><span class="line">    ************************</span><br><span class="line">    ----------------------------------------------------------------</span><br><span class="line">            Layer (type)               Output Shape         Param #</span><br><span class="line">    &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">                Conv2d-1            [1, 16, 64, 64]             160</span><br><span class="line">                Conv2d-2            [1, 32, 64, 64]             544</span><br><span class="line">    &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    Total params: 704</span><br><span class="line">    Trainable params: 704</span><br><span class="line">    Non-trainable params: 0</span><br><span class="line">    ----------------------------------------------------------------</span><br></pre></td></tr></table></figure></code></pre><ol start="19"><li></li></ol><hr><h1 id="SELayer"><a href="#SELayer" class="headerlink" title="SELayer"></a>SELayer</h1><p><strong>Squeeze-and-Excitation Networks</strong></p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200830153344.png" alt="image-20200830114911949"></p><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200830153339.png" alt="image-20200830140039015"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">torch.Size([<span class="number">2</span>, <span class="number">512</span>, <span class="number">64</span>, <span class="number">64</span>])</span><br><span class="line">b = <span class="number">2</span> c = <span class="number">512</span></span><br><span class="line">torch.Size([<span class="number">2</span>, <span class="number">512</span>])</span><br><span class="line">After LinearFC, tmp.shape = torch.Size([<span class="number">2</span>, <span class="number">32</span>])</span><br><span class="line">After RELU, tmp.shape = torch.Size([<span class="number">2</span>, <span class="number">32</span>])</span><br><span class="line">After LinearFC2, tmp.shape = torch.Size([<span class="number">2</span>, <span class="number">512</span>])</span><br><span class="line">After SIGMOID, tmp.shape = torch.Size([<span class="number">2</span>, <span class="number">512</span>])</span><br><span class="line">torch.Size([<span class="number">2</span>, <span class="number">512</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">        Layer (type)               Output Shape         Param <span class="comment">#</span></span><br><span class="line">================================================================</span><br><span class="line"> AdaptiveAvgPool2d<span class="number">-1</span>            [<span class="number">-1</span>, <span class="number">512</span>, <span class="number">1</span>, <span class="number">1</span>]               <span class="number">0</span></span><br><span class="line">            Linear<span class="number">-2</span>                   [<span class="number">-1</span>, <span class="number">32</span>]          <span class="number">16</span>,<span class="number">384</span></span><br><span class="line">              ReLU<span class="number">-3</span>                   [<span class="number">-1</span>, <span class="number">32</span>]               <span class="number">0</span></span><br><span class="line">            Linear<span class="number">-4</span>                  [<span class="number">-1</span>, <span class="number">512</span>]          <span class="number">16</span>,<span class="number">384</span></span><br><span class="line">           Sigmoid<span class="number">-5</span>                  [<span class="number">-1</span>, <span class="number">512</span>]               <span class="number">0</span></span><br><span class="line">            Linear<span class="number">-6</span>                   [<span class="number">-1</span>, <span class="number">32</span>]          <span class="number">16</span>,<span class="number">384</span></span><br><span class="line">              ReLU<span class="number">-7</span>                   [<span class="number">-1</span>, <span class="number">32</span>]               <span class="number">0</span></span><br><span class="line">            Linear<span class="number">-8</span>                  [<span class="number">-1</span>, <span class="number">512</span>]          <span class="number">16</span>,<span class="number">384</span></span><br><span class="line">           Sigmoid<span class="number">-9</span>                  [<span class="number">-1</span>, <span class="number">512</span>]               <span class="number">0</span></span><br><span class="line">================================================================</span><br><span class="line">Total params: <span class="number">65</span>,<span class="number">536</span></span><br><span class="line">Trainable params: <span class="number">65</span>,<span class="number">536</span></span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">Input size (MB): <span class="number">8.00</span></span><br><span class="line">Forward/backward <span class="keyword">pass</span> size (MB): <span class="number">0.02</span></span><br><span class="line">Params size (MB): <span class="number">0.25</span></span><br><span class="line">Estimated Total Size (MB): <span class="number">8.27</span></span><br><span class="line">----------------------------------------------------------------</span><br></pre></td></tr></table></figure><p><img src="https://blog-1301959139.cos.ap-beijing.myqcloud.com/picGo/20200830153225.png" alt="image-20200830153224613"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;几种卷积类型辨析&quot;&gt;&lt;a href=&quot;#几种卷积类型辨析&quot; class=&quot;headerlink&quot; title=&quot;几种卷积类型辨析&quot;&gt;&lt;/a&gt;几种卷积类型辨析&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;conv = nn.Conv2d(in_channels=&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, out_channels=&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, kernel_size=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, groups=&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conv.weight.data.size()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# output = torch.Size([6, 2, 1, 1])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;一种分类方法：&lt;/p&gt;
&lt;p&gt;几种卷积示意：（分组卷积 &lt;strong&gt;group_convolution&lt;/strong&gt;；深度卷积 &lt;strong&gt;depthwise convolution&lt;/strong&gt;； 全局深度卷积 &lt;strong&gt;global depthwise convolution&lt;/strong&gt;）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;groups 默认值为1， 对应的是&lt;strong&gt;常规卷积&lt;/strong&gt;操作&lt;/li&gt;
&lt;li&gt;groups &amp;gt; 1， 且能够同时被in_channel / out_channel整除，对应&lt;strong&gt;group_convolution&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;groups == input_channel == out_channel , 对应&lt;strong&gt;depthwise convolution&lt;/strong&gt;,为条件2的特殊情况&lt;/li&gt;
&lt;li&gt;在条件3的基础上，各卷积核的 H == input_height; W == input_width, 对应为 &lt;strong&gt;global depthwise convolution&lt;/strong&gt;, 为条件3的特殊情况&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;另一种分类方法：&lt;strong&gt;主要分三类：正常卷积、分组卷积、深度分离卷积&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="组会" scheme="http://yoursite.com/categories/%E7%BB%84%E4%BC%9A/"/>
    
    
      <category term="组会" scheme="http://yoursite.com/tags/%E7%BB%84%E4%BC%9A/"/>
    
      <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
  </entry>
  
</feed>
